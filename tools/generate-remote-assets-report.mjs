import fs from 'node:fs/promises'
import path from 'node:path'

const projectRoot = process.cwd()
const cacheLogPath = path.join(projectRoot, '.cache', 'remote-assets.log')
const docsDir = path.join(projectRoot, 'docs')
const outputPath = path.join(docsDir, 'remote-assets-audit.md')

function formatTableRow(host, count) {
  return `| ${host} | ${count.toLocaleString()} |`
}

async function ensureDocsDir() {
  await fs.mkdir(docsDir, { recursive: true })
}

async function readLog() {
  try {
    const raw = await fs.readFile(cacheLogPath, 'utf8')
    return raw.split(/\r?\n/).map(line => line.trim()).filter(Boolean)
  } catch (error) {
    throw new Error(`Unable to read ${cacheLogPath}: ${error.message || error}`)
  }
}

function analyse(urls) {
  const unique = new Set()
  const hostMap = new Map()

  for (const entry of urls) {
    if (unique.has(entry)) {
      continue
    }
    unique.add(entry)

    try {
      const u = new URL(entry)
      const host = u.host || ''
      if (!hostMap.has(host)) {
        hostMap.set(host, { host, count: 0, samples: [] })
      }
      const meta = hostMap.get(host)
      meta.count++
      if (meta.samples.length < 10) {
        meta.samples.push(entry)
      }
    } catch {
      if (!hostMap.has('<invalid>')) {
        hostMap.set('<invalid>', { host: '<invalid>', count: 0, samples: [] })
      }
      const meta = hostMap.get('<invalid>')
      meta.count++
      if (meta.samples.length < 10) {
        meta.samples.push(entry)
      }
    }
  }

  const hosts = Array.from(hostMap.values()).sort((a, b) => b.count - a.count)
  return { uniqueCount: unique.size, hosts }
}

function buildMarkdown(report) {
  const lines = []
  const timestamp = new Date().toISOString()

  lines.push('# Remote Asset Audit')
  lines.push('')
  lines.push(`- Generated: ${timestamp}`)
  lines.push(`- Source log: .cache/remote-assets.log`)
  lines.push(`- Unique asset URLs: ${report.uniqueCount.toLocaleString()}`)
  lines.push(`- Unique hosts: ${report.hosts.length.toLocaleString()}`)
  lines.push('')
  lines.push(
    'This file is generated by `tools/generate-remote-assets-report.mjs`. Re-run the script after a fresh `npm run build` to update the inventory.',
  )
  lines.push('')
  if (report.hosts.length > 0) {
    lines.push('## Host Breakdown')
    lines.push('')
    lines.push('| Host | Cached Assets |')
    lines.push('| --- | ---: |')
    for (const host of report.hosts) {
      lines.push(formatTableRow(host.host || '<unknown>', host.count))
    }
    lines.push('')
  }

  lines.push('## Sample URLs')
  lines.push('')
  const samples = []
  for (const host of report.hosts) {
    samples.push(...host.samples)
    if (samples.length >= 20) {
      break
    }
  }
  if (samples.length === 0) {
    lines.push('_No remote assets were cached during the last build._')
  } else {
    for (const url of samples.slice(0, 20)) {
      lines.push(`- ${url}`)
    }
  }
  lines.push('')

  return `${lines.join('\n')}`
}

async function writeReport(markdown) {
  await ensureDocsDir()
  await fs.writeFile(outputPath, `${markdown}\n`, 'utf8')
}

async function main() {
  const entries = await readLog()
  const report = analyse(entries)
  const markdown = buildMarkdown(report)
  await writeReport(markdown)
  console.log(
    `Wrote remote asset audit (${report.uniqueCount} URLs) to ${
      path.relative(projectRoot, outputPath)
    }`,
  )
}

main().catch(error => {
  console.error(error.message || error)
  process.exitCode = 1
})
