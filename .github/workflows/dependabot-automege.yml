name: Dependabot Auto-Merge (Native, Gated)

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]

permissions:
  contents: write          # needed for auto-merge toggle via GraphQL
  pull-requests: write     # needed to approve
  checks: read
  statuses: read

jobs:
  automerge:
    if: >
      github.event.pull_request.user.login == 'dependabot[bot]' &&
      !github.event.pull_request.draft
    runs-on: ubuntu-latest

    concurrency:
      group: dependabot-automerge-${{ github.event.pull_request.number }}
      cancel-in-progress: false

    steps:
      - name: Fetch Dependabot metadata
        id: meta
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      # Gate: only minor/patch or security updates
      - name: Approve PR
        if: >
          contains(steps.meta.outputs.update-type, 'semver-patch') ||
          contains(steps.meta.outputs.update-type, 'semver-minor') ||
          startsWith(steps.meta.outputs.update-type, 'security')
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;
            await github.rest.pulls.createReview({
              owner, repo, pull_number: number,
              event: 'APPROVE',
              body: 'Auto-approval for Dependabot (minor/patch or security).'
            });
            core.info(`Approved PR #${number}`);

      # Robust, native enablement: wait for mergeability to stabilize, then enable auto-merge (squash)
      - name: Enable auto-merge (native, gated)
        if: >
          contains(steps.meta.outputs.update-type, 'semver-patch') ||
          contains(steps.meta.outputs.update-type, 'semver-minor') ||
          startsWith(steps.meta.outputs.update-type, 'security')
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const {owner, repo} = context.repo;
            const number = context.payload.pull_request.number;

            const Q = `
              query($owner:String!, $repo:String!, $number:Int!) {
                repository(owner:$owner, name:$repo) {
                  autoMergeAllowed
                  pullRequest(number:$number) {
                    id
                    isDraft
                    state
                    mergeStateStatus
                    reviewDecision
                    commits(last:1) {
                      nodes {
                        commit { oid statusCheckRollup { state } } # SUCCESS | FAILURE | PENDING | null
                      }
                    }
                  }
                }
              }`;

            const enable = async (id) => {
              const M = `mutation Enable($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }) {
                  pullRequest { number state autoMergeRequest { enabledAt } }
                }
              }`;
              return await github.graphql(M, { pullRequestId: id, mergeMethod: "SQUASH" });
            };

            const prInfo = async () => await github.graphql(Q, {owner, repo, number});
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            // Up to ~3 minutes of gentle polling
            for (let i=0; i<18; i++) {
              const r = await prInfo();
              if (!r.repository.autoMergeAllowed) {
                core.setFailed("Repo setting 'Allow auto-merge' is OFF.");
              }
              const pr = r.repository.pullRequest;
              const roll = pr.commits.nodes[0]?.commit?.statusCheckRollup?.state || "UNKNOWN";
              core.info(`mergeStateStatus=${pr.mergeStateStatus} statusCheckRollup=${roll}`);

              // If checks are failing, don't attempt to enable; try again on next run
              if (pr.mergeStateStatus === "UNSTABLE" && roll === "FAILURE") {
                core.info("Checks failing â†’ skip enablement (will re-run on new commits).");
                return;
              }

              // If not pending and mergeability isn't UNKNOWN, try to enable
              if (roll !== "PENDING" && pr.mergeStateStatus !== "UNKNOWN") {
                try {
                  const res = await enable(pr.id);
                  core.info(`Auto-merge enabled on PR #${res.enablePullRequestAutoMerge.pullRequest.number}`);
                  return;
                } catch (e) {
                  if (/unstable status|UNKNOWN|mergeability/i.test(e.message)) {
                    core.warning(`Transient: ${e.message}; retrying...`);
                  } else {
                    throw e; // real failure
                  }
                }
              }
              await sleep(10000);
            }
            core.setFailed("Gave up enabling auto-merge (mergeability never stabilized).");
