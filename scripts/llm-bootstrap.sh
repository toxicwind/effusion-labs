#!/usr/bin/env bash
#
# Autonomous LLM Guardrail Environment
#
# IMPORTANT: This script is meant to be SOURCED, not executed directly.
# Sourcing it injects the guardrails into the current shell session.
#
# Correct Usage: source scripts/llm-bootstrap.sh
#
# This script:
# 1. Injects a heartbeat into long-running shell sessions to prevent CI timeouts.
# 2. Hijacks commands to rewrite `npm test > file` to a safe, streaming pipeline.
# 3. Blocks the use of `tail` to prevent non-streaming workarounds.
# 4. Installs self-repairing Git hooks for persistence across checkouts.
#
# The script can be sourced multiple times without issue.

# Determine the repository root directory.
# BASH_SOURCE is an array, [0] is the script itself.
repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# --- Configuration & Persistence ---
# This part runs every time to ensure the environment is always correctly configured.

# Define the entire guardrail environment logic using a HEREDOC.
read -r -d '' BASH_ENV_CONTENT <<'EOF'
# Auto-generated by scripts/llm-bootstrap.sh. Do not edit manually.
# This file is sourced by new Bash shells to activate LLM guardrails.

[[ -d "$PWD/.git" ]] || return 0
[[ "${LLM_HIJACK_DISABLE:-}" == "1" ]] && return 0

export LLM_KEEPALIVE_IMPORTS='--import=./test/setup/http.mjs --import=./test/setup/llm-keepalive.mjs'

llm_shell_hb() {
  local interval=$(( ${LLM_HEARTBEAT_SECS:-15} * 4 )); (( interval < 30 )) && interval=30
  while true; do
    printf '::notice:: LLM-safe: shell alive @ %s\n' "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >&2; sleep "$interval";
  done
}

_llm_hijack() {
  [[ "${_LLM_REWRITE_ACTIVE:-}" == "1" ]] && return 0
  local cmd="$BASH_COMMAND"

  if [[ "$cmd" =~ ^npm\ (run\ )?test ]]; then
    if [[ "$cmd" =~ \s+(1>|>)\s*([^\s&]+)\s*(2>&1)?$ && ! "$cmd" =~ \| ]]; then
      local outfile="${BASH_REMATCH[2]}"; local redirect_pattern="${BASH_REMATCH[0]}"
      local base_cmd="${cmd%$redirect_pattern}"
      printf '::notice:: LLM-safe: rewrote "%s" -> fold | tee\n' "$cmd" >&2
      export _LLM_REWRITE_ACTIVE=1; export LLM_KEEPALIVE_INJECTED=1
      eval "$base_cmd 2>&1 | fold -w 4000 -s | tee -i '$outfile'";
      BASH_COMMAND=:; unset _LLM_REWRITE_ACTIVE; return 0;
    fi
  fi

  if [[ "$cmd" =~ ^\s*tail(\s|$) ]]; then
      printf "::error:: Guardrail Violation: Direct use of 'tail' is forbidden.\n" >&2
      printf "::error:: Rationale: This pattern encourages non-streaming commands, which can hide errors and cause timeouts.\n" >&2
      printf "::error:: Please rely on the direct, streaming output from commands instead.\n" >&2
      BASH_COMMAND=":"; return 0;
  fi
}

if [[ "${CI:-}" == "true" || "${LLM_SHELL_HEARTBEAT:-}" == "1" ]]; then
  # Avoid starting duplicate heartbeats if script is sourced multiple times.
  if [[ -z "${_LLM_HB_PID:-}" ]] || ! kill -0 "$_LLM_HB_PID" 2>/dev/null; then
    llm_shell_hb &
    export _LLM_HB_PID=$!
    trap 'kill "$_LLM_HB_PID" 2>/dev/null' EXIT
  fi
fi
trap _llm_hijack DEBUG
EOF

# Write the hijack logic to the BASH_ENV file for persistence in sub-shells.
echo "$BASH_ENV_CONTENT" > "$repo_root/.llm-bash-env"

# Install Git hooks to ensure the environment is self-repairing.
for hook in post-checkout post-merge; do
  hook_path="$repo_root/.git/hooks/$hook"
  cat > "$hook_path" <<'EOH'
#!/usr/bin/env bash
# Auto-restores LLM guardrails. To apply to your current shell, run:
# source scripts/llm-bootstrap.sh
bash scripts/llm-bootstrap.sh >/dev/null 2>&1
EOH
  chmod +x "$hook_path"
done

# --- Live Activation ---
# This is the magic. When the script is sourced, this line executes
# the hijack logic we just defined, activating it in the current shell.
eval "$BASH_ENV_CONTENT"

echo "âœ… LLM Guardrails are now **ACTIVE** in this shell session."