#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# Effusion Labs — LLM-First Guardrail Bootstrap (2025 • instrumented, aggressive)
# Correct usage:  source scripts/llm-bootstrap.sh
#
# LLM CONTRACT
# • Redirects → live stream + fold + tee; preserves exit code; supports > and >>.
# • tail -f/-F blocked by default; emits bounded, folded snapshot instead.
# • cat is FOR THE LLM: always attempt Prettier normalization for known types.
# • All key actions emit grepable lines:  ::notice:: LLM-GUARD event=<...> k=v ...
# ------------------------------------------------------------------------------

# ======= knobs (LLM-first defaults) =======
: "${LLM_VERBOSE:=1}"              # 1=emit notices; 0=quiet
: "${LLM_HIJACK_DISABLE:=0}"       # 1=disable redirect hijack
: "${LLM_HEARTBEAT_SECS:=15}"      # base seconds; internally *4 (min 30)
: "${LLM_FOLD_WIDTH:=4000}"        # fold width to avoid 4096 truncation
: "${LLM_TAIL_BLOCK:=1}"           # 1=block tail -f/-F
: "${LLM_TAIL_MAX_LINES:=5000}"    # snapshot size when follow is blocked
: "${LLM_TAIL_ALLOW_CMDS:=}"       # optional regex allowlist for follow
: "${LLM_CAT_MAX_BYTES:=0}"        # 0=unbounded; >0 = skip Prettier if file larger (performance guard)

_llm_emit_boot() {
  [[ "${LLM_VERBOSE}" != "1" ]] && return 0
  local ts; ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  printf '::notice:: LLM-GUARD ts=%s event=%s' "$ts" "$1" >&2
  shift; while [[ $# -gt 0 ]]; do printf ' %s' "$1" >&2; shift; done; printf '\n' >&2
  [[ -n "${GITHUB_STEP_SUMMARY:-}" ]] && printf 'LLM-GUARD %s %s\n' "$ts" "$*" >> "$GITHUB_STEP_SUMMARY"
}

set -u
repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
_llm_emit_boot bootstrap.start repo_root="$repo_root"

# ======= 1) Portable dependency check (non-recursive) =======
: "${LLM_BOOTSTRAP_LOCK:=}"
if [[ -z "${npm_lifecycle_event:-}" && -z "$LLM_BOOTSTRAP_LOCK" ]]; then
  export LLM_BOOTSTRAP_LOCK=1
  mkdir -p "$repo_root/tmp"
  DEPS_HASH_FILE="$repo_root/tmp/.llm_deps_hash"

  hash_inputs=()
  [[ -f "$repo_root/package-lock.json" ]] && hash_inputs+=("$repo_root/package-lock.json")
  [[ -f "$repo_root/markdown_gateway/requirements.txt" ]] && hash_inputs+=("$repo_root/markdown_gateway/requirements.txt")

  if (( ${#hash_inputs[@]} )); then
    if command -v sha256sum >/dev/null 2>&1; then
      current_hash="$(cat "${hash_inputs[@]}" | sha256sum | awk '{print $1}')"
    else
      current_hash="$(cat "${hash_inputs[@]}" | shasum -a 256 | awk '{print $1}')"
    fi
  else
    current_hash=""
  fi
  stored_hash="$( [[ -f "$DEPS_HASH_FILE" ]] && cat "$DEPS_HASH_FILE" || printf '' )"

  if [[ -n "$current_hash" && "$current_hash" != "$stored_hash" ]]; then
    _llm_emit_boot bootstrap.deps.install node=ci python=requirements.txt
    CI=${CI:-false} npm ci
    if [[ -f "$repo_root/markdown_gateway/requirements.txt" ]]; then
      if command -v python >/dev/null 2>&1; then python -m pip install -r "$repo_root/markdown_gateway/requirements.txt"
      else pip install -r "$repo_root/markdown_gateway/requirements.txt"; fi
    fi
    echo "$current_hash" > "$DEPS_HASH_FILE"
  else
    _llm_emit_boot bootstrap.deps.unchanged
  fi
fi

# ======= 2) Guardrail env: hijack, anti-tail, LLM-cat, heartbeat =======
read -r -d '' BASH_ENV_CONTENT <<'EOF'
# --- auto-generated by llm-bootstrap.sh ---
# shellcheck disable=SC2154

_llm_bool() { [[ "${1:-0}" == "1" || "${1:-0}" == "true" ]]; }

_llm_emit() {
  [[ "${LLM_VERBOSE:-1}" != "1" ]] && return 0
  local event="$1"; shift
  local ts; ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  printf '::notice:: LLM-GUARD ts=%s event=%s' "$ts" "$event" >&2
  while [[ $# -gt 0 ]]; do printf ' %s' "$1" >&2; shift; done; printf '\n' >&2
  if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
    printf 'LLM-GUARD %s event=%s' "$ts" "$event" >> "$GITHUB_STEP_SUMMARY"
    # shellcheck disable=SC2124
    printf ' %s\n' "$*" >> "$GITHUB_STEP_SUMMARY"
  fi
}

# ---- LLM-first cat: always try to pretty-print with Prettier ----
# Strategy:
# 1) Prefer repo-local prettier: node_modules/.bin/prettier (fast, offline).
# 2) Fallback: npx --no-install prettier (uses devDep, no registry).
# 3) If prettier unavailable or file too large (LLM_CAT_MAX_BYTES), stream raw but still fold.
_prettier_bin() {
  local bin_local
  bin_local="$(git rev-parse --show-toplevel 2>/dev/null)/node_modules/.bin/prettier"
  if [[ -x "$bin_local" ]]; then echo "$bin_local"; return 0; fi
  if command -v npx >/dev/null 2>&1; then echo "npx --no-install prettier"; return 0; fi
  echo "" ; return 1
}

smart_cat() {
  local p="$1"
  if [[ ! -f "$p" ]]; then command cat -vt -- "$p" | fold -w "${LLM_FOLD_WIDTH:-4000}" -s; return; fi
  local size ext parser
  size=$(wc -c <"$p" 2>/dev/null || echo 0)
  ext="${p##*.}"; parser=""
  case "$ext" in
    js|mjs|cjs) parser="babel" ;;
    ts|tsx)     parser="babel-ts" ;;
    json|jsonl) parser="json" ;;
    md|markdown) parser="markdown" ;;
    html|htm)   parser="html" ;;
    css|pcss)   parser="css" ;;
    yml|yaml)   parser="yaml" ;;
    *) parser="" ;;
  esac

  local bin; bin="$(_prettier_bin || true)"

  if [[ -n "$parser" && -n "$bin" && ( "${LLM_CAT_MAX_BYTES:-0}" -eq 0 || "$size" -le "${LLM_CAT_MAX_BYTES:-0}" ) ]]; then
    _llm_emit cat.format file="$p" bytes="$size" parser="$parser"
    # shellcheck disable=SC2086
    command cat -- "$p" | $bin --parser "$parser" --print-width "${LLM_FOLD_WIDTH:-100}" 2>/dev/null \
      | fold -w "${LLM_FOLD_WIDTH:-4000}" -s
  else
    # Either unknown type / too large / prettier not found — fall back to raw folded
    _llm_emit cat.raw file="$p" bytes="$size" reason="$([[ -z "$bin" ]] && echo no-prettier || ([[ -z "$parser" ]] && echo unknown-type || echo size-cap))"
    command cat -vt -- "$p" | fold -w "${LLM_FOLD_WIDTH:-4000}" -s
  fi
}

# ---- Anti-spiral tail: block follow by default ----
_llm_tail() {
  local follow=0 arg outfile
  for arg in "$@"; do [[ "$arg" == "-f" || "$arg" == "-F" ]] && follow=1; done
  if _llm_bool "${LLM_TAIL_BLOCK:-1}" && (( follow )); then
    if [[ -n "${LLM_TAIL_ALLOW_CMDS:-}" && "${BASH_COMMAND:-}" =~ ${LLM_TAIL_ALLOW_CMDS} ]]; then
      _llm_emit tail.pass reason=allowlist args="$*"
      command tail "$@"; return $?
    fi
    for ((i=$#; i>=1; --i)); do
      if [[ -f "${!i}" ]]; then outfile="${!i}"; break; fi
    done
    if [[ -n "${outfile:-}" ]]; then
      _llm_emit tail.block file="$outfile" lines="${LLM_TAIL_MAX_LINES:-5000}" folded="${LLM_FOLD_WIDTH:-4000}"
      command tail -n "${LLM_TAIL_MAX_LINES:-5000}" -- "$outfile" | fold -w "${LLM_FOLD_WIDTH:-4000}" -s
      return ${PIPESTATUS[0]}
    fi
  fi
  _llm_emit tail.pass args="$*"
  if command -v stdbuf >/dev/null 2>&1; then
    command tail "$@" | stdbuf -o0 -e0 cat | fold -w "${LLM_FOLD_WIDTH:-4000}" -s
  else
    command tail "$@" | fold -w "${LLM_FOLD_WIDTH:-4000}" -s
  fi
}

# ---- Redirect hijack: `cmd > file` / `cmd >> file` → live stream + fold + tee ----
_llm_hijack() {
  [[ "${LLM_HIJACK_DISABLE:-0}" == "1" ]] && return 0
  [[ "${_LLM_REWRITE_ACTIVE:-}" == "1" ]] && return 0
  [[ -z "${BASH_COMMAND:-}" ]] && return 0
  local cmd="$BASH_COMMAND"
  if [[ "$cmd" =~ [[:space:]](1?\>\>|\>)[[:space:]]*([^[:space:]&|;]+)[[:space:]]*(2\>\&1)?$ ]] && \
     [[ ! "$cmd" =~ \| ]] && [[ ! "$cmd" =~ \&\& ]] && [[ ! "$cmd" =~ \|\| ]]; then
    local op="${BASH_REMATCH[1]}" outfile="${BASH_REMATCH[2]}" base="${cmd%${BASH_REMATCH[0]}}"
    local tee_flag=""; case "$op" in '>>'|'1>>') tee_flag='-a' ;; esac
    _llm_emit hijack.rewrite op="$op" file="$outfile" fold="${LLM_FOLD_WIDTH:-4000}" append=$([[ -n "$tee_flag" ]] && printf true || printf false)
    export _LLM_REWRITE_ACTIVE=1
    (
      set -o pipefail
      if command -v stdbuf >/dev/null 2>&1; then
        bash -c "$base" 2>&1 | stdbuf -o0 -e0 cat
      else
        bash -c "$base" 2>&1
      fi
    ) | fold -w "${LLM_FOLD_WIDTH:-4000}" -s | tee $tee_flag -- "$outfile"
    local status=${PIPESTATUS[0]}
    unset _LLM_REWRITE_ACTIVE
    BASH_COMMAND=:
    return "$status"
  fi
}

# ---- Heartbeat ----
_llm_hb() {
  local interval=$(( ${LLM_HEARTBEAT_SECS:-15} * 4 )); (( interval < 30 )) && interval=30
  while true; do _llm_emit heartbeat interval="${interval}s"; sleep "$interval"; done
}

# Export & aggressive activation (LLM-first)
export -f smart_cat
export -f _llm_tail
export -f _llm_hijack
export -f _llm_hb
alias cat='smart_cat'     # ALWAYS alias cat for LLM normalization
alias tail='_llm_tail'

_llm_emit bootstrap.alias cat=smart_cat tail=_llm_tail tail_block="${LLM_TAIL_BLOCK:-1}"
printf 'llm-bootstrap: cat -> smart_cat (prettier-first); tail -> _llm_tail (tail -f/-F blocked). Use "command cat" or "command tail" for raw commands.\n' >&2

trap _llm_hijack DEBUG

if [[ "${CI:-}" == "true" || "${LLM_SHELL_HEARTBEAT:-0}" == "1" ]]; then
  if [[ -z "${_LLM_HB_PID:-}" ]] || ! kill -0 "$_LLM_HB_PID" 2>/dev/null; then
    _llm_hb & export _LLM_HB_PID=$!; trap 'kill "$_LLM_HB_PID" 2>/dev/null || true' EXIT
  fi
fi

_llm_emit bootstrap.ready fold="${LLM_FOLD_WIDTH:-4000}" tail_block="${LLM_TAIL_BLOCK:-1}" cat_mode=prettier-first
# --- end auto-generated block ---
EOF

# ======= 3) Persist & activate =======
echo "$BASH_ENV_CONTENT" > "$repo_root/.llm-bash-env"

for hook in post-checkout post-merge; do
  hook_path="$repo_root/.git/hooks/$hook"
  cat > "$hook_path" <<'EOH'
#!/usr/bin/env bash
set -euo pipefail
repo_root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
# shellcheck source=/dev/null
. "$repo_root/.llm-bash-env"
EOH
  chmod +x "$hook_path"
done

# shellcheck source=/dev/null
. "$repo_root/.llm-bash-env"

_llm_emit_boot bootstrap.done fold="$LLM_FOLD_WIDTH" tail_block="$LLM_TAIL_BLOCK" verbose="$LLM_VERBOSE" cat="prettier-first"
printf 'LLM-GUARD summary: hijack=%s fold=%s tail_block=%s cat=prettier-first verbose=%s\n' \
  "$([[ "$LLM_HIJACK_DISABLE" == "1" ]] && printf disabled || printf enabled)" \
  "$LLM_FOLD_WIDTH" "$LLM_TAIL_BLOCK" "$LLM_VERBOSE" >&2
