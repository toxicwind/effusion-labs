#!/usr/bin/env bash
# A smart shim for npm that handles output buffering for test commands.
set -euo pipefail

# Compute real npm binary, skipping this shim
DIR="$(cd "$(dirname "$0")" && pwd)"
PATH_WITHOUT_DIR=$(printf "%s" "$PATH" | sed "s|$DIR:||;s|:$DIR||;s|$DIR||")
NPM_BIN="$(PATH="$PATH_WITHOUT_DIR" command -v npm)"
if [ -z "$NPM_BIN" ]; then
  echo "npm binary not found" >&2
  exit 127
fi

# Helper to run npm with a PTY so output streams in real time
run_with_pty() {
  if command -v script >/dev/null 2>&1; then
    cmd="$NPM_BIN $(printf '%q ' "$@")"
    script -q -e -c "$cmd" /dev/null
    return $?
  elif command -v unbuffer >/dev/null 2>&1; then
    unbuffer "$NPM_BIN" "$@"
    return $?
  elif command -v expect >/dev/null 2>&1; then
    expect -c "spawn -noecho $NPM_BIN $(printf '%q ' "$@"); interact"
    return $?
  elif command -v stdbuf >/dev/null 2>&1; then
    stdbuf -oL -eL "$NPM_BIN" "$@"
    return $?
  else
    "$NPM_BIN" "$@"
    return $?
  fi
}

# Check if the command is 'test'. This is often the command that suffers
# from I/O buffering when run in non-interactive shells.
if [ "$1" = "test" ]; then
  # For 'npm test', use PTY/line buffering strategies to ensure streaming.
  echo "::notice:: NPM-SHIM: Using PTY wrapper for 'npm test' to ensure output streaming." >&2
  run_with_pty "$@"
else
  # For all other commands (install, run build, etc.), execute directly.
  exec "$NPM_BIN" "$@"
fi
