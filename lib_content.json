{
  "src/assets/js/app.js": "// src/assets/js/app.js\n// Vite entry. Import CSS here so Vite builds and HMRs it.\nimport \"/assets/css/app.css\";",
  "src/assets/js/mschf-overlay.js": "// Effusion Labs — Hypebrüt Overlay v2.1 (Garden-Calm)\n// Non-blocking, prose-safe, SPA-safe, mobile-sane, reduced-motion/data aware.\n// Console: __mschfOn(), __mschfOff(), __mschfPulse(), __mschfMood(m), __mschfDensity(x), __mschfMask(0|1), __mschfAlpha(x)\n\n(() => {\n  if (window.__mschfBooted) {\n    try { console.warn('[MSCHF] Boot skipped — already booted.'); } catch {}\n    return;\n  }\n  window.__mschfBooted = true;\n\n  // ————————————————————————————————————————\n  // Debug toggles & helpers\n  // Enable with: body[data-mschf-debug=\"1\"], localStorage.setItem('mschf:debug','1'),\n  // window.__MSCHF_DEBUG = true, or URL ?mschfDebug=1\n  // ————————————————————————————————————————\n  const q = typeof location !== 'undefined' ? location.search : '';\n  const scope0 = (typeof document !== 'undefined' ? (document.body || document.documentElement) : null);\n  const DEBUG = !!(\n    (scope0 && scope0.dataset && scope0.dataset.mschfDebug === '1') ||\n    (typeof localStorage !== 'undefined' && localStorage.getItem('mschf:debug') === '1') ||\n    (typeof window !== 'undefined' && window.__MSCHF_DEBUG) ||\n    /(^|[?&])mschfDebug=1(&|$)/.test(q)\n  );\n  const SID = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2,7)}`;\n  const C = { mount:0, retire:0, composeInitial:0, recompose:0, rare:0, io:0, beats:0, bars:0 };\n  const qparam = (name) => { try { return new URLSearchParams(q).get(name); } catch { return null; } };\n  const log = (...a) => { if (DEBUG) try { console.log('[MSCHF]', ...a); } catch {} };\n  const warn = (...a) => { if (DEBUG) try { console.warn('[MSCHF]', ...a); } catch {} };\n  const group = (label) => DEBUG && console.groupCollapsed && console.groupCollapsed(`[MSCHF] ${label}`);\n  const groupEnd = () => DEBUG && console.groupEnd && console.groupEnd();\n  try { if (DEBUG) console.info('[MSCHF] Debug ON — session', SID); } catch {}\n\n  // ————————————————————————————————————————\n  // Guards / kill switch\n  // ————————————————————————————————————————\n  const scope = document.body || document.documentElement;\n  if (!scope) return;\n  if (scope.dataset.mschf === 'off') return;\n  if (localStorage.getItem('mschf:off') === '1') return;\n  if (DEBUG) { scope.dataset.mschfDebug = '1'; log('Booting overlay…', { session: SID, dataset: { ...scope.dataset } }); }\n\n  // ————————————————————————————————————————\n  // Utilities\n  // ————————————————————————————————————————\n  const clamp = (v, a, b) => Math.min(b, Math.max(a, v));\n  const lerp  = (a, b, t) => a + (b - a) * t;\n  const now   = () => performance.now();\n  const pick  = (arr) => arr[Math.floor(Math.random() * arr.length)];\n  const css   = (el, obj) => { for (const k in obj) el.style[k] = obj[k]; return el; };\n  const el    = (tag, cls, parent) => {\n    const n = document.createElement(tag);\n    if (cls) n.className = cls;\n    (parent||document.body).appendChild(n);\n    // harden pass-through on *every* node we create\n    n.style.pointerEvents = 'none';\n    n.style.userSelect = 'none';\n    // Debug tagging: attach actor metadata to all created nodes during a mount()\n    try {\n      if (State && State._mountCtx) {\n        n.dataset.mschf = '1';\n        n.dataset.mschfKind = State._mountCtx.kind || 'unknown';\n        n.dataset.mschfFamily = State._mountCtx.family || 'unknown';\n        n.dataset.mschfId = String(State._mountCtx.id || '0');\n        // helper classes for quick CSS targeting\n        if (State._mountCtx.kind) n.classList.add(`mschf-k-${State._mountCtx.kind}`);\n        if (State._mountCtx.family) n.classList.add(`mschf-f-${State._mountCtx.family}`);\n      }\n    } catch {}\n    return n;\n  };\n\n  // External dep loader (PixiJS v8)\n  async function loadPixi() {\n    if (globalThis.PIXI && globalThis.PIXI.Application) return globalThis.PIXI;\n    const sources = [\n      'https://cdn.jsdelivr.net/npm/pixi.js@8.2.1/dist/pixi.min.mjs',\n      'https://esm.sh/pixi.js@8',\n      'https://cdn.skypack.dev/pixi.js@8'\n    ];\n    for (const src of sources) {\n      try { const mod = await import(/* @vite-ignore */ src); return mod.default || mod; } catch {}\n    }\n    return null;\n  }\n\n  function resolveBlend(PIXI, name) {\n    const map = PIXI?.BLEND_MODES;\n    return map && map[name] !== undefined ? map[name] : name.toLowerCase().replace(/_/g, '-');\n  }\n\n  // ————————————————————————————————————————\n  // Global State\n  // ————————————————————————————————————————\n  const State = {\n    root: null, domLayer: null, app: null,\n    style: scope.dataset.mschfStyle || 'auto',\n    densityToken: scope.dataset.mschfDensity || 'calm',\n    density: 0.38, // gentler default\n    mood: 'calm', // calm → lite → bold → loud → storm → studio\n    tempo: 1.0,\n    reduceMotion: matchMedia?.('(prefers-reduced-motion: reduce)').matches || false,\n    reduceData: !!(navigator.connection && (navigator.connection.saveData || /2g/.test(navigator.connection.effectiveType||''))),\n    visible: !document.hidden,\n    nodeBudget: 120, nodeCount: 0,\n    actors: new Set(),\n    families: { scaffold: new Set(), ephemera: new Set(), lab: new Set(), frame: new Set() },\n    beats: { last: now(), dur: 680 },\n    bars:  { last: now(), dur: 4200 },\n    safeZones: [],\n    occupancy: [],\n    actorBoxes: new Map(), // id -> rect {x,y,w,h}\n    cornerSlots: { tl:null, tr:null, bl:null, br:null },\n    readingPressure: 0,\n    gridCols: 10,\n    gridRows: 6,\n    paused: false,\n    fps: { samples: [], bad: false },\n    tiers: { xs: false, sm: false, md: false, lg: false },\n    // hard caps per family to bound DOM churn; recomputed by tier/pressure\n    caps: { scaffold: 6, ephemera: 6, lab: 4, frame: 5 },\n    alpha: 0.85, // overall overlay alpha (debuggable)\n    gpu: { maskOn: true, stageAlpha: 1.0 },\n    // runtime config knobs\n    config: {\n      // 'once' (default): single recomposition; 'auto': periodic; 'off': never after initial\n      recompose: (scope.dataset.mschfRecompose || qparam('mschfRecompose') || 'once').toLowerCase(),\n      // Default rare moments OFF; enable with data-mschf-rare=\"1\" or ?mschfRare=1\n      rare: (() => { const a = scope.dataset.mschfRare; const b = qparam('mschfRare'); return a !== undefined ? a === '1' : b === '1'; })(),\n      // Visual toggles for specific lab elements\n      rings: (() => { const a = scope.dataset.mschfRings; const p = qparam('mschfRings'); return a!=null ? a!=='0' : (p!=null ? p!=='0' : true); })(),\n      topo:  (() => { const a = scope.dataset.mschfTopo;  const p = qparam('mschfTopo');  return a!=null ? a!=='0' : (p!=null ? p!=='0' : true); })(),\n      // GPU-layer toggles (default off for calm sites)\n      gpuRings: (() => { const a = scope.dataset.mschfGpuRings; const p = qparam('mschfGpuRings'); return a!=null ? a!=='0' : (p!=null ? p!=='0' : false); })(),\n      gpuTopo:  (() => { const a = scope.dataset.mschfGpuTopo;  const p = qparam('mschfGpuTopo');  return a!=null ? a!=='0' : (p!=null ? p!=='0' : false); })(),\n      gpuStars: (() => { const a = scope.dataset.mschfGpuStars; const p = qparam('mschfGpuStars'); return a!=null ? a!=='0' : (p!=null ? p!=='0' : false); })(),\n    },\n    _didRecompose: false,\n    _t0: now(),\n    debug: {\n      // Aggressive when DEBUG=true (?mschfDebug=1), quiet otherwise\n      labelsOn: (() => { const p = qparam('mschfLabels'); const d = scope.dataset.mschfLabels; return (p!=null? p!=='0' : (d!=null? d!=='0' : DEBUG)); })(),\n      hudOn:     (() => { const p = qparam('mschfHUD');    const d = scope.dataset.mschfHud;   return (p!=null? p!=='0' : (d!=null? d!=='0' : DEBUG)); })(),\n      autoPick:  (() => { const p = qparam('mschfAutoPick'); const d = scope.dataset.mschfPick; return (p!=null? p!=='0' : (d!=null? d!=='0' : DEBUG)); })(),\n      lastLabelUpdate: 0,\n    },\n    _labels: new Map(),\n    labelLayer: null,\n    hud: null,\n  };\n\n  // Density from token (softened a touch)\n  const densityMap = { calm: 0.22, lite: 0.38, bold: 0.58, loud: 0.75 };\n  if (densityMap[State.densityToken]) State.density = densityMap[State.densityToken];\n\n  // Style: default to calm+structural for clarity\n  if (State.style === 'auto') State.style = 'structural';\n\n  // ————————————————————————————————————————\n  // Root mount\n  // ————————————————————————————————————————\n  function mountRoot() {\n    let root = document.getElementById('mschf-overlay-root');\n    if (!root) { root = el('div','',document.body); root.id = 'mschf-overlay-root'; DEBUG && log('Created overlay root'); }\n    else { DEBUG && log('Reusing overlay root', { childCount: root.childElementCount }); }\n    css(root, {\n      pointerEvents:'none', userSelect:'none',\n      position:'fixed', inset:'0', width:'100vw', height:'100vh',\n      zIndex: getComputedStyle(document.documentElement).getPropertyValue('--mschf-z')?.trim() || '44',\n      color:'currentColor', contain:'layout style paint', contentVisibility:'auto',\n      opacity: State.alpha // global soften\n    });\n    root.setAttribute('aria-hidden','true');\n    root.dataset.mschfSession = SID;\n    if (root.childElementCount) DEBUG && warn('Root was not empty before mount; clearing');\n    root.innerHTML = '';\n    const domLayer = el('div','mschf-layer',root);\n    css(domLayer,{ position:'absolute', inset:0, pointerEvents:'none', userSelect:'none' });\n    // dev label layer\n    const labelLayer = el('div','mschf-devlayer',root);\n    css(labelLayer,{ position:'absolute', inset:0, pointerEvents:'none', userSelect:'none' });\n    const hud = el('div','mschf-hud',root);\n    css(hud,{ position:'fixed', left:'6px', top:'6px', pointerEvents:'none', userSelect:'none', zIndex: '999999', color:'#00ff41', background:'rgba(0,0,0,.58)', border:'1px solid rgba(0,255,65,.6)', borderRadius:'6px', padding:'6px 8px', font:'700 10px/1.2 ui-monospace,Menlo,monospace', letterSpacing:'.06em' });\n    if (!State.debug.hudOn) { hud.style.display = 'none'; }\n    State.root = root; State.domLayer = domLayer; State.labelLayer = labelLayer; State.hud = hud;\n    if (DEBUG && 'MutationObserver' in window) {\n      const mo = new MutationObserver((muts)=>{\n        let added=0, removed=0; for (const m of muts){ added += (m.addedNodes?.length||0); removed += (m.removedNodes?.length||0); }\n        if (added||removed) log('DOM layer mutation', {\n          added, removed, childCount: State.domLayer?.childElementCount||0,\n          actors: State.actors.size,\n          families: { scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size },\n          caps: State.caps, nodeBudget: State.nodeBudget, nodeCount: State.nodeCount\n        });\n      });\n      mo.observe(domLayer, { childList: true });\n      State._mo = mo;\n    }\n  }\n\n  // ————————————————————————————————————————\n  // Mobile tiers + budgets\n  // ————————————————————————————————————————\n  function computeTiers() {\n    const w = innerWidth;\n    State.tiers.xs = w < 480;\n    State.tiers.sm = w >= 480 && w < 768;\n    State.tiers.md = w >= 768 && w < 1024;\n    State.tiers.lg = w >= 1024;\n\n    // tiered budgets\n    State.nodeBudget = State.tiers.lg ? 110 : State.tiers.md ? 90 : 60;\n    if (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) State.nodeBudget = Math.min(State.nodeBudget, 70);\n\n    computeCaps();\n  }\n\n  // ————————————————————————————————————————\n  // Safe zones & placement\n  // ————————————————————————————————————————\n  function computeSafeZones() {\n    const selFallback = '.prose, main, article, header, nav, .map-cta, [data-safe], [data-mschf-safe], [data-occlude=\"avoid\"]';\n    const sel = scope.getAttribute('data-mschf-safe') || selFallback;\n    const pad = 24; // ↑ from 16\n    const rects = [...document.querySelectorAll(sel)]\n      .map(n => n.getBoundingClientRect())\n      .filter(r => r.width * r.height > 0)\n      .map(r => ({\n        x: clamp(r.left - pad, 0, innerWidth),\n        y: clamp(r.top - pad, 0, innerHeight),\n        w: clamp(r.width + pad*2, 0, innerWidth),\n        h: clamp(r.height + pad*2, 0, innerHeight)\n      }));\n    State.safeZones = rects;\n    GPU.updateMask(); // keep GPU from painting over prose\n  }\n\n  // Clip each rect to the viewport; measure visible text only\n  function computeReadingPressure() {\n    const W = innerWidth, H = innerHeight;\n    const clip = r =>\n      Math.max(0, Math.min(r.right, W) - Math.max(r.left, 0)) *\n      Math.max(0, Math.min(r.bottom, H) - Math.max(r.top, 0));\n\n    let area = 0;\n    document.querySelectorAll('p, li, blockquote').forEach(n => {\n      const r = n.getBoundingClientRect();\n      area += clip(r);\n    });\n    const total = W * H || 1;\n    State.readingPressure = clamp(area / total, 0, 1);\n  }\n  function computeContext(){ computeSafeZones(); computeReadingPressure(); computeCaps(); }\n\n  // Recompute per-family caps by tier, density, motion, and reading pressure\n  function computeCaps(){\n    const base = State.tiers.lg ? { ephemera: 8, lab: 6, frame: 6 }\n               : State.tiers.md ? { ephemera: 6, lab: 4, frame: 5 }\n               :                  { ephemera: 3, lab: 2, frame: 3 };\n    const pressureMod = State.readingPressure > 0.25 ? 0.6 : 1.0;\n    const motionMod   = State.reduceMotion ? 0.75 : 1.0;\n    const densityMod  = lerp(0.6, 1.0, clamp(State.density, 0.2, 0.8));\n    State.caps = {\n      scaffold: 6,\n      ephemera: Math.max(1, Math.floor(base.ephemera * pressureMod * motionMod * densityMod)),\n      lab:      Math.max(1, Math.floor(base.lab      * pressureMod * motionMod * densityMod)),\n      frame:    Math.max(1, Math.floor(base.frame    * pressureMod * motionMod * densityMod)),\n    };\n  }\n  function rectOverlap(a,b) {\n    const x = Math.max(0, Math.min(a.x+a.w, b.x+b.w) - Math.max(a.x, b.x));\n    const y = Math.max(0, Math.min(a.y+a.h, b.y+b.h) - Math.max(a.y, b.y));\n    return x*y;\n  }\n  function collidesSafe(r) {\n    const area = Math.max(1, r.w * r.h);\n    for (const z of State.safeZones) if (rectOverlap(r,z)/area > 0.02) return true; // stricter\n    return false;\n  }\n  function collidesActors(r){\n    const area = Math.max(1, r.w * r.h);\n    for (const [,z] of State.actorBoxes){ if (rectOverlap(r,z)/area > 0.06) return true; }\n    return false;\n  }\n  function collidesAny(r){ return collidesSafe(r) || collidesActors(r); }\n  function resetOccupancy() { State.occupancy = new Array(State.gridCols*State.gridRows).fill(0); }\n  function isCellFree(c,r){ return !State.occupancy[r*State.gridCols + c]; }\n  function claimCell(c,r){ State.occupancy[r*State.gridCols + c] = 1; }\n\n  // Corner occupancy manager — prevents stacking actors in corners\n  const CNR = {\n    all: ['tl','tr','bl','br'],\n    free(){ return this.all.filter(c => !State.cornerSlots[c]); },\n    isFree(c){ return !State.cornerSlots[c]; },\n    can(corners){ return corners.every(c => !State.cornerSlots[c]); },\n    pick(){ const f = this.free(); return f.length ? pick(f) : null; },\n    claim(actor, corners){\n      actor._corners = actor._corners || [];\n      for (const c of corners){ State.cornerSlots[c] = actor; actor._corners.push(c); }\n    },\n    release(actor){ if (!actor || !actor._corners) return; for(const c of actor._corners){ if (State.cornerSlots[c]===actor) State.cornerSlots[c]=null; } actor._corners.length=0; }\n  };\n\n  // Zoned placement with optional affinity\n  function findSpot(w,h,aff='anywhere') {\n    const tryGutter = () => {\n      const left = Math.random() < 0.5;\n      const x = left ? Math.round(Math.random()*Math.min(innerWidth*0.1, 120)) : Math.round(innerWidth - w - Math.random()*Math.min(innerWidth*0.1, 120));\n      const y = Math.round(Math.random()*(innerHeight - h));\n      const rect = { x, y, w, h }; if (!collidesAny(rect)) return rect;\n      return null;\n    };\n    const tryCorners = () => {\n      const pad = 8;\n      const pos = pick(['tl','tr','bl','br']);\n      const x = pos.includes('l') ? pad : innerWidth - w - pad;\n      const y = pos.includes('t') ? pad : innerHeight - h - pad;\n      const rect = { x, y, w, h }; if (!collidesAny(rect)) return rect;\n      return null;\n    };\n    const tryHeader = () => {\n      const pad = 12;\n      const x = Math.round(Math.random()*(innerWidth - w));\n      const y = pad;\n      const rect = { x, y, w, h }; if (!collidesAny(rect)) return rect;\n      return null;\n    };\n    const primary = aff==='corners'?tryCorners:aff==='gutters'?tryGutter:aff==='header'?tryHeader:null;\n    if (primary) for (let i=0;i<12;i++){ const r=primary(); if (r) return r; }\n    if (aff!=='gutters') for (let i=0;i<8;i++){ const r=tryGutter(); if(r) return r; }\n\n    const maxTry = 28;\n    for (let i=0;i<maxTry;i++) {\n      const cx = Math.floor(Math.random()*State.gridCols);\n      const cy = Math.floor(Math.random()*State.gridRows);\n      if (!isCellFree(cx,cy)) continue;\n      const rx = Math.round((cx/State.gridCols)*innerWidth);\n      const ry = Math.round((cy/State.gridRows)*innerHeight);\n      const rect = { x: clamp(rx - w*0.1, 0, innerWidth - w), y: clamp(ry - h*0.1, 0, innerHeight - h), w, h };\n      if (!collidesAny(rect)) { claimCell(cx,cy); return rect; }\n    }\n    return { x: Math.round(Math.random()*(innerWidth - w)), y: Math.round(Math.random()*(innerHeight - h)), w, h };\n  }\n\n  // ————————————————————————————————————————\n  // Mood machine (calmer + article caps)\n  // ————————————————————————————————————————\n  const moods = ['calm','lite','bold','loud','storm','studio'];\n  function nextMood(cur){\n    const idx = moods.indexOf(cur);\n    const roll = Math.random();\n    let step = roll < 0.7 ? 1 : roll < 0.92 ? 2 : 3; // drift slower\n    if (State.readingPressure < 0.1 && Math.random() < 0.4) step++;\n    let next = moods[Math.min(idx + step, moods.length - 1)];\n    if (State.readingPressure > 0.25 && ['bold','loud','storm','studio'].includes(next)) next = 'lite';\n    return next;\n  }\n  function applyMood(mood){\n    if (State.readingPressure > 0.25 && ['bold','loud','storm','studio'].includes(mood)) mood = 'lite';\n    State.mood = mood;\n\n    const t = { calm:.95, lite:1.0, bold:1.1, loud:1.18, storm:1.25, studio:.95 }[mood] || 1.0;\n    State.tempo = t;\n\n    // calmer bar/beat lengths\n    State.bars.dur  = lerp(3400, 5200, 1/(State.tempo+.01));\n    State.beats.dur = lerp(580,  820,  1/(State.tempo+.01));\n\n    // density settles toward base, then capped by page type\n    const base = { calm:.22, lite:.38, bold:.55, loud:.7, storm:.85, studio:.35 }[mood] || .4;\n    State.density = clamp(lerp(State.density, base, .6), .18, .9);\n\n    const isArticle = !!document.querySelector('.prose,[data-kind=\"spark\"],[data-kind=\"concept\"],[data-kind=\"project\"],article,main .prose');\n    if (isArticle) State.density = Math.min(State.density, .45);\n    if (State.tiers.xs || State.tiers.sm) State.density = Math.min(State.density, .45);\n\n    if (State.root) State.root.dataset.mood = mood;\n\n    // GPU flourish guardrails\n    GPU.toggleGlow(!isArticle && /loud|storm/.test(mood));\n  }\n\n  // ————————————————————————————————————————\n  // GPU (PixiJS) layer — prose-masked\n  // ————————————————————————————————————————\n  const GPU = {\n    app: null, stage: null, rings: null, topo: null, starfield: null, glow: null, maskG: null,\n    async init() {\n      if (State.reduceData) return null;\n      // Only on large screens by default\n      if (!State.tiers.lg) return null;\n      DEBUG && log('GPU.init start');\n      const PIXI = await loadPixi();\n      if (!PIXI) { DEBUG && warn('GPU.init failed: PIXI not available'); return null; }\n\n      const app = new PIXI.Application();\n      await app.init({\n        width: innerWidth, height: innerHeight, antialias: true, autoDensity: true, backgroundAlpha: 0,\n        powerPreference: 'high-performance', useBackBuffer: false,\n        resolution: devicePixelRatio > 2 ? 2 : devicePixelRatio\n      });\n      State.root.appendChild(app.canvas);\n      css(app.canvas, { position:'absolute', inset:0, pointerEvents:'none', userSelect:'none' });\n\n      const stage = app.stage;\n      this.app = app; this.stage = stage;\n      DEBUG && log('GPU.init ok');\n\n      // Mask that punches holes over safe zones (so GPU never overlays prose)\n      this.updateMask();\n\n      // Rings (GPU) — optional\n      if (State.config.gpuRings) {\n        this.rings = this.makeRings(PIXI);\n        stage.addChild(this.rings.container);\n      }\n\n      // Topo (GPU) — optional\n      if (State.config.gpuTopo) {\n        this.topo = this.makeTopo(PIXI);\n        stage.addChild(this.topo.container);\n      }\n\n      // Starfield (very subtle) — optional\n      if (State.config.gpuStars) {\n        this.starfield = this.makeStars(PIXI);\n        stage.addChild(this.starfield.container);\n      }\n\n      // No CRT by default (was visually heavy over text)\n\n      // Context loss handling (recover or gracefully degrade)\n      try {\n        app.canvas.addEventListener('webglcontextlost', (ev)=>{ ev.preventDefault(); State._gpuLost = true; DEBUG && warn('GPU context lost'); }, false);\n        app.canvas.addEventListener('webglcontextrestored', ()=>{ State._gpuLost = false; DEBUG && log('GPU context restored'); this.topo?.resize?.(); this.rings?.resize?.(); this.starfield?.resize?.(); }, false);\n      } catch {}\n\n      // Resize\n      addEventListener('resize', () => {\n        app.renderer.resize(innerWidth, innerHeight);\n        this.rings?.resize(); this.topo?.resize(); this.starfield?.resize();\n        this.updateMask();\n      });\n\n      return app;\n    },\n\n    updateMask() {\n      if (!this.stage || !this.app) return;\n      const PIXI = this.app.renderer.plugins?.graphics?.graphicsFactory?.renderer?.PIXI || globalThis.PIXI;\n      if (!PIXI) return;\n\n      if (!this.maskG) this.maskG = new PIXI.Graphics();\n      this.maskG.clear();\n\n      if (State.gpu.maskOn) {\n        this.maskG.beginFill(0xffffff, 1);\n        this.maskG.drawRect(0,0,innerWidth,innerHeight);\n        for (const z of State.safeZones) {\n          this.maskG.beginHole();\n          this.maskG.drawRoundedRect(z.x, z.y, z.w, z.h, 8);\n          this.maskG.endHole();\n        }\n        this.maskG.endFill();\n        this.stage.mask = this.maskG;\n        if (!this.maskG.parent) this.stage.addChild(this.maskG);\n        DEBUG && log('GPU.mask on', { holes: State.safeZones.length });\n      } else {\n        // mask off\n        if (this.stage.mask) this.stage.mask = null;\n        if (this.maskG.parent) this.maskG.removeFromParent();\n        DEBUG && log('GPU.mask off');\n      }\n    },\n\n    toggleGlow(enable) {\n      if (!this.stage || State.reduceMotion) return;\n      const want = !!enable;\n      if (want && !this.glow) {\n        (async () => {\n          try {\n            const { GlowFilter } = await import('https://cdn.jsdelivr.net/npm/@pixi/filter-glow@5.2.1/dist/filter-glow.min.mjs').catch(()=>({}));\n            if (GlowFilter) {\n              this.glow = new GlowFilter({ distance: 10, outerStrength: 0.18, innerStrength: 0.0, color: 0xffffff, quality: .25 });\n              this.stage.filters = [this.glow];\n            }\n          } catch {}\n        })();\n      } else if (!want && this.glow) {\n        this.stage.filters = null; this.glow = null;\n      }\n    },\n\n    makeRings(PIXI) {\n      const container = new PIXI.Container(); container.alpha = .08; // softer\n      const g = new PIXI.Graphics(); container.addChild(g);\n\n      function draw(cx, cy, baseR, color) {\n        g.clear();\n        g.blendMode = resolveBlend(PIXI,'ADD');\n        g.lineStyle(1, color, 1);\n        for (let i=0;i<3;i++) g.drawCircle(cx, cy, baseR + i*baseR*.33);\n        g.endFill();\n      }\n\n      let cx = innerWidth*0.5, cy = innerHeight*0.28, base = Math.min(innerWidth, innerHeight)*0.052;\n      let tint = 0xffffff;\n\n      function resize(){ cx = innerWidth*0.5; cy = Math.max(64, innerHeight*0.26); base = Math.min(innerWidth, innerHeight)*0.05; }\n      function step(t){\n        if (State.reduceMotion) { draw(cx, cy, base, tint); return; }\n        const beat = 1 + Math.sin(t/1400) * .05 * State.tempo;\n        draw(cx, cy, base*beat, tint);\n      }\n      resize();\n      return { container, step, resize };\n    },\n\n    makeTopo(PIXI) {\n      const container = new PIXI.Container(); container.alpha = .06;\n      const g = new PIXI.Graphics(); container.addChild(g);\n\n      function draw(){\n        g.clear(); g.blendMode = resolveBlend(PIXI,'SCREEN');\n        const w = innerWidth, h = innerHeight;\n        const lines = 14;\n        for (let i=0;i<lines;i++){\n          const y = (h/lines)*i + Math.sin(i*1.23)*4;\n          g.lineStyle(1, 0xffffff, .32);\n          g.moveTo(0, y);\n          for (let x=0;x<=w;x+=28){\n            const yy = y + Math.sin((x*0.01)+(i*0.6))*4 + Math.sin((x*0.031)-(i))*2.5;\n            g.lineTo(x, yy);\n          }\n        }\n      }\n      function resize(){ draw(); }\n      function step(t){\n        if (State.reduceMotion) return;\n        if (Math.random() < 0.015 * State.tempo) draw();\n      }\n      draw();\n      return { container, step, resize };\n    },\n\n    makeStars(PIXI) {\n      const container = new PIXI.Container(); container.alpha = .05;\n      container.blendMode = resolveBlend(PIXI,'SCREEN');\n      const starTex = PIXI.Texture.WHITE;\n      const sprites = [];\n\n      function populate(){\n        container.removeChildren(); sprites.length = 0;\n        const n = Math.floor(40 + (State.density*60) * (State.tiers.lg ? 1 : .6));\n        for (let i=0;i<n;i++){\n          const s = new PIXI.Sprite(starTex);\n          const size = Math.random()*1.6 + .4;\n          s.tint = 0xffffff; s.alpha = Math.random()*.6 + .2;\n          s.width = size; s.height = size;\n          s.x = Math.random()*innerWidth; s.y = Math.random()*innerHeight;\n          container.addChild(s); sprites.push(s);\n        }\n      }\n      function resize(){ populate(); }\n      function step(){\n        if (State.reduceMotion || State.tiers.xs) return;\n        if (Math.random() < 0.25) return;\n        const k = (State.tempo * 0.1) * (State.tiers.lg ? 1 : .6);\n        for (let i=0;i<sprites.length;i+=7){\n          const s = sprites[i];\n          s.y += (Math.random() - .5) * k;\n          s.x += (Math.random() - .5) * k;\n          if (s.x<0) s.x=innerWidth; if (s.x>innerWidth) s.x=0;\n          if (s.y<0) s.y=innerHeight; if (s.y>innerHeight) s.y=0;\n        }\n      }\n      populate();\n      return { container, step, resize };\n    },\n\n    step(t){\n      if (!this.stage) return;\n      this.rings?.step(t);\n      this.topo?.step(t);\n      this.starfield?.step(t);\n      // stage alpha adapts slightly to pressure\n      this.stage.alpha = State.gpu.stageAlpha = lerp(0.75, 1.0, 1 - State.readingPressure*0.5);\n    }\n  };\n\n  // ————————————————————————————————————————\n  // Actor Framework (DOM ornaments)\n  // ————————————————————————————————————————\n  function mount(actor, family){\n    if (!actor) return;\n    if (DEBUG) group(`mount try: ${actor.kind || 'unknown'} → ${family}`);\n\n    // honor budget\n    const cost = actor.cost || 1;\n    if (State.nodeCount + cost > State.nodeBudget) { DEBUG && warn('bail: nodeBudget cap', { nodeCount: State.nodeCount, cost, nodeBudget: State.nodeBudget }); return void(groupEnd()); }\n\n    // family caps: bail if at capacity\n    const cap = (State.caps && State.caps[family]) || Infinity;\n    if (State.families[family] && State.families[family].size >= cap) { DEBUG && warn('bail: family cap', { family, size: State.families[family].size, cap }); return void(groupEnd()); }\n\n    const isArticle = !!document.querySelector('.prose,[data-kind=\"spark\"],[data-kind=\"concept\"],[data-kind=\"project\"],article,main .prose');\n\n    // Preflight: corner occupancy (avoid stacking multiple corner-bound actors)\n    const wantsCorners = (k)=> ['reg','pips','corners'].includes(k||'');\n    if ((actor.kind||'') === 'stickers'){\n      const chosen = CNR.pick();\n      if (!chosen){ DEBUG && warn('bail: no free corner for stickers'); return DEBUG && groupEnd(), false; }\n      actor.corner = chosen; // handed to actor.mount\n      CNR.claim(actor, [chosen]);\n    } else if (wantsCorners(actor.kind)){\n      if (!CNR.can(['tl','tr','bl','br'])){ DEBUG && warn('bail: corners occupied'); return DEBUG && groupEnd(), false; }\n      CNR.claim(actor, ['tl','tr','bl','br']);\n    }\n\n    // small screens: only minimal scaffold & frame affordances\n    if ((State.tiers.xs || State.tiers.sm) && family !== 'scaffold') {\n      const allow = ['frame','corners','rulers','brackets','reg','dims'];\n      if (!allow.includes(actor.kind || '')) { DEBUG && warn('bail: small-screen filter', { kind: actor.kind, family }); return void(groupEnd()); }\n    }\n    // articles: quiet only\n    if (isArticle && family !== 'scaffold') {\n      const quiet = ['tape','quotes','specimen','plate','dims','reg','brackets','stickers'];\n      if (!quiet.includes(actor.kind || '') && State.density > .45) { DEBUG && warn('bail: article quiet filter', { kind: actor.kind, density: State.density }); return void(groupEnd()); }\n    }\n\n    // assign uid and expose mount context for debug tagging\n    actor._id = (State.seq = (State.seq||0) + 1);\n    State._mountCtx = { id: actor._id, kind: actor.kind, family };\n    State.families[family].add(actor);\n    State.actors.add(actor);\n    State.nodeCount += cost;\n    try { actor.mount(State.domLayer); } catch (e) { DEBUG && warn('actor.mount threw', e); CNR.release(actor); return DEBUG && groupEnd(), false; }\n    // record bounding box to discourage future overlaps\n    try {\n      const r = actor.node?.getBoundingClientRect?.();\n      if (r && isFinite(r.width) && isFinite(r.height)) {\n        const rect = { x: Math.max(0, r.left), y: Math.max(0, r.top), w: Math.max(0, r.width), h: Math.max(0, r.height) };\n        State.actorBoxes.set(actor._id, rect);\n      }\n    } catch {}\n    State._mountCtx = null;\n    // If primary node exists, tag it too\n    try {\n      if (actor.node && actor.node.nodeType === 1) {\n        actor.node.dataset.mschf = '1';\n        actor.node.dataset.mschfKind = actor.kind || 'unknown';\n        actor.node.dataset.mschfFamily = family;\n        actor.node.dataset.mschfId = String(actor._id);\n        actor.node.classList.add(`mschf-k-${actor.kind||'unknown'}`, `mschf-f-${family}`);\n      }\n    } catch {}\n    C.mount++;\n    // text and bbox for quicker mapping\n    let text='';\n    try { text = (actor.node && actor.node.textContent || '').trim().slice(0,48); } catch {}\n    let bbox=null; try { const r = actor.node?.getBoundingClientRect?.(); if (r) bbox = { x:Math.round(r.x), y:Math.round(r.y), w:Math.round(r.width), h:Math.round(r.height) }; } catch {}\n    DEBUG && log('mounted', { id: actor._id, kind: actor.kind, family, text, bbox, node: actor.node, cost, nodeCount: State.nodeCount, sizes: {\n      scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size\n    }});\n    DEBUG && groupEnd();\n    return true;\n  }\n  function retire(actor){\n    if (!actor) return;\n    if (DEBUG) group(`retire: ${actor.kind || 'unknown'}`);\n    try { actor.retire && actor.retire(); } catch (e) { DEBUG && warn('actor.retire threw', e); }\n    try { actor.node && actor.node.remove(); } catch {}\n    try { State.actorBoxes.delete(actor._id); } catch {}\n    try { CNR.release(actor); } catch {}\n    try { const lab = State._labels.get(actor._id); if (lab) { lab.remove(); State._labels.delete(actor._id); } } catch {}\n    State.actors.delete(actor);\n    for (const k in State.families) State.families[k].delete(actor);\n    State.nodeCount = Math.max(0, State.nodeCount - (actor.cost || 1));\n    C.retire++;\n    DEBUG && log('retired', { id: actor._id, kind: actor.kind, nodeCount: State.nodeCount, sizes: {\n      scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size\n    }});\n    DEBUG && groupEnd();\n  }\n\n  const A = {}; // actor factory bag\n\n  // Scaffold (always gentle + pass-through nodes already enforced by el())\n  const gridMeta = { affinity:'anywhere', complexity:2 };\n  A.grid = () => {\n    let node; return {\n      kind:'grid', cost:1, ...gridMeta,\n      mount(p){ node = el('div','mschf-grid',p); node.dataset.variant = Math.random()<.5?'dots':'lines'; },\n      update(){ if (Math.random()< .0015 * State.tempo) node.dataset.variant = node.dataset.variant==='dots'?'lines':'dots'; },\n      node\n    };\n  };\n  A.grid.meta = gridMeta;\n  const frameMeta = { affinity:'anywhere', complexity:2 };\n  A.frame = () => {\n    let node; return {\n      kind:'frame', cost:1, ...frameMeta,\n      mount(p){ node = el('div','mschf-frame',p); },\n      update(t){ node.style.setProperty('--mschf-glow', (0.10 + Math.sin(t/2600)*0.04*State.tempo).toFixed(3)); },\n      node\n    };\n  };\n  A.frame.meta = frameMeta;\n  const cornersMeta = { affinity:'corners', complexity:1 };\n  A.corners = () => {\n    const nodes=[]; return {\n      kind:'corners', cost:1, ...cornersMeta,\n      mount(p){ ['tl','tr','bl','br'].forEach(pos=>nodes.push(el('div',`mschf-corner mschf-corner-${pos}`,p))); },\n      node:{ remove(){ nodes.forEach(n=>n.remove()); } }\n    };\n  };\n  A.corners.meta = cornersMeta;\n  const rulersMeta = { affinity:'anywhere', complexity:1 };\n  A.rulers = () => {\n    let top,left; return {\n      kind:'rulers', cost:1, ...rulersMeta,\n      mount(p){ top=el('div','mschf-ruler mschf-ruler-top',p); left=el('div','mschf-ruler mschf-ruler-left',p); },\n      node:{ remove(){ top.remove(); left.remove(); } }\n    };\n  };\n  A.rulers.meta = rulersMeta;\n  const scanMeta = { affinity:'anywhere', complexity:2 };\n  A.scanline = () => {\n    let node; return {\n      kind:'scan', cost:1, ...scanMeta,\n      mount(p){ node = el('div','mschf-scanline',p); if (State.reduceMotion) node.classList.add('static'); },\n      update(){ if (!State.reduceMotion && Math.random()<0.0015) node.classList.toggle('static', Math.random()<0.5); },\n      node\n    };\n  };\n  A.scanline.meta = scanMeta;\n\n  // Ephemera (mostly gutters/corners)\n  const TAPE_LEX = [\n    '\"KEEP OFF\"','\"FOR RESEARCH ONLY\"','\"SANDBOX\"','\"SPECIMEN\"','\"ARCHIVE\"','\"EVIDENCE\"','\"PROTOTYPE\"',\n    '\"ALPHA\"','\"BETA\"','\"RC1\"','\"NIGHTLY\"','\"CANARY\"','\"WIP\"','\"READ ONLY\"','\"NO INDEX\"',\n    '\"GRAPH\"','\"VECTOR\"','\"RAG\"','\"EVAL\"','\"INTERFACE\"','\"ATLAS\"','\"SPARK\"'\n  ];\n  const tapeMeta = { affinity:'corners', complexity:2 };\n  A.tape = () => {\n    let node, rect={x:0,y:0,w:0,h:0}, life=1;\n    return {\n      kind:'tape', cost:1, ...tapeMeta,\n      mount(p){\n        node = el('div','mschf-tape',p);\n        node.classList.add(pick(['tone-a','tone-b','tone-c']));\n        node.textContent = `${pick(TAPE_LEX)} • RIG-${Math.floor(Math.random()*0xffff).toString(16).padStart(4,'0').toUpperCase()}`;\n        if (Math.random() < (/(bold|loud|storm)/.test(State.mood)?0.35:0.15)) node.dataset.hazard='1';\n        if (Math.random() < 0.14) node.dataset.clear='1';\n        const wvw = Math.round(24 + Math.random()*44);\n        const h = 24 + Math.random()*10;\n        rect = findSpot(innerWidth*(wvw/100), h, this.affinity);\n        const rot = (Math.random()-0.5) * (/(loud|storm)/.test(State.mood)?12:5);\n        css(node,{ top:rect.y+'px', left:rect.x+'px', width:wvw+'vw', transform:`rotate(${rot}deg)`, opacity: State.mood==='calm'?'.18':'.28' });\n      },\n      update(_t,dt){\n        if (State.tiers.xs) return;\n        rect.x = clamp(rect.x + (Math.random()-0.5)*0.28*State.tempo, 0, innerWidth - (node.offsetWidth||0));\n        rect.y = clamp(rect.y + (Math.random()-0.5)*0.20*State.tempo, 0, innerHeight - (node.offsetHeight||0));\n        node.style.left = rect.x+'px'; node.style.top = rect.y+'px';\n        life -= dt * 0.00005 * (0.6 + State.tempo);\n        if (life < 0) this.dead = true;\n      },\n      retire(){ node.classList.add('out'); },\n      node\n    };\n  };\n  A.tape.meta = tapeMeta;\n\n  const STAMPS = ['LAB DROP','EXPERIMENTAL','UNSTABLE','READ ONLY','DECLASSIFIED','NONCANON','INTERNAL','RETRY','RECALIBRATE','ARCHIVE ONLY'];\n  const stampMeta = { affinity:'corners', complexity:2 };\n  A.stamp = () => {\n    let node; return {\n      kind:'stamp', cost:1, ...stampMeta,\n      mount(p){\n        node = el('div','mschf-stamp',p); node.textContent = pick(STAMPS);\n        const pos = pick(['top-right','top-left','bottom-right','bottom-left']);\n        const rot = (Math.random()-0.5)*10, ix=6+Math.floor(Math.random()*14), iy=8+Math.floor(Math.random()*16);\n        const s={ transform:`rotate(${rot}deg)` };\n        if (pos.includes('top')) s.top=iy+'%'; else s.bottom=iy+'%';\n        if (pos.includes('right')) s.right=ix+'%'; else s.left=ix+'%';\n        css(node, s);\n      },\n      node\n    };\n  };\n  A.stamp.meta = stampMeta;\n\n  const quotesMeta = { affinity:'anywhere', complexity:1 };\n  A.quotes = () => {\n    let node; return {\n      kind:'quotes', cost:1, ...quotesMeta,\n      mount(p){\n        node = el('div','mschf-quotes',p);\n        const idtail = Math.random().toString(36).slice(2,5).toUpperCase();\n        node.textContent = `${pick(['\"OBJECT\"','\"INTERFACE\"','\"ARTIFACT\"','\"SYSTEM\"','\"SPECIMEN\"','\"SANDBOX\"','\"VECTOR\"','\"EMBEDDING\"','\"RAG\"','\"EVAL\"'])} • ${idtail}`;\n        const side = Math.random()<0.5?'right':'left', vertical = Math.random()<0.3?'top':'bottom';\n        const offX = 12 + Math.floor(Math.random()*24), offY = 10 + Math.floor(Math.random()*18);\n        const s={}; if(side==='right') s.right=offX+'px'; else s.left=offX+'px'; if(vertical==='top') s.top=offY+'px'; else s.bottom=offY+'px';\n        s.transform = `rotate(${(Math.random()-0.5)*2.0}deg)`; css(node,s);\n      },\n      node\n    };\n  };\n  A.quotes.meta = quotesMeta;\n\n  const plateMeta = { affinity:'gutters', complexity:3 };\n  A.plate = () => {\n    let node, code; return {\n      kind:'plate', cost:1, ...plateMeta,\n      mount(p){\n        node = el('div','mschf-plate',p); el('div','mschf-barcode',node); code = el('div','mschf-code',node);\n        const tail = Math.random().toString(16).slice(-6).toUpperCase();\n        const stamp = new Date().toISOString().slice(0,10);\n        code.textContent = `SEED:${tail} • ${document.body.dataset.buildBranch || 'BR:main'} • ${stamp}`;\n        css(node,{ left:'18px', top:'18px' });\n      },\n      node\n    };\n  };\n  A.plate.meta = plateMeta;\n\n  const specimenMeta = { affinity:'gutters', complexity:2 };\n  A.specimen = () => {\n    let node; return {\n      kind:'specimen', cost:1, ...specimenMeta,\n      mount(p){\n        node = el('div','mschf-specimen',p);\n        const id = Math.random().toString(36).slice(2,7).toUpperCase();\n        const hash = (document.body.dataset.buildHash||'').slice(0,7);\n        const date = (document.body.dataset.builtAt || new Date().toISOString()).slice(0,10);\n        const branch = document.body.dataset.buildBranch || 'main';\n        const rev = pick(['A','B','C','D']);\n        const path = location?.pathname || '/';\n        node.innerHTML = `<strong>SPECIMEN</strong><span>ID ${id}</span>${hash?`<span>BUILD ${hash}</span>`:''}<span>${date}</span><span>BR ${branch}</span><span>REV ${rev}</span><span>PATH ${path}</span>`;\n        const side = Math.random()<0.5?'right':'left', offX = 18+Math.floor(Math.random()*24), offY = 16+Math.floor(Math.random()*20);\n        const s={}; if(side==='right') s.right=offX+'px'; else s.left=offX+'px'; s.top=offY+'px'; css(node,s);\n      },\n      node\n    };\n  };\n  A.specimen.meta = specimenMeta;\n\n  // Lab / blueprint\n  const calloutMeta = { affinity:'gutters', complexity:1 };\n  A.callout = () => {\n    let node; return {\n      kind:'callout', cost:1, ...calloutMeta,\n      mount(p){\n        node = el('div','mschf-callout',p);\n        const labels = ['NODE','EDGE','VECTOR','EVAL','β','Δt','ID'];\n        const val = Math.random().toString(36).slice(2,5).toUpperCase();\n        node.textContent = `${pick(labels)} ${val} • ${(Math.random()*0.99).toFixed(2)}`;\n\n        // Place in a safe, non-overlapping spot (avoid prose)\n        // Temporarily attach for measurement\n        node.style.visibility = 'hidden';\n        requestAnimationFrame(()=>{\n          try{\n            const r = node.getBoundingClientRect();\n            const spot = findSpot(Math.max(60, r.width||120), Math.max(18, r.height||18), 'gutters');\n            node.style.setProperty('--x', `${(spot.x/innerWidth)*100}vw`);\n            node.style.setProperty('--y', `${(spot.y/innerHeight)*100}vh`);\n            const len = 6 + Math.random()*10; node.style.setProperty('--len', `${len}vh`);\n            node.style.visibility = '';\n          } catch { node.style.visibility=''; }\n        });\n      },\n      update(t){\n        if (!node) return;\n        const base = /(loud|storm|studio)/.test(State.mood)? .74 : .66;\n        const o = lerp(base*0.6, base, 1 - clamp(State.readingPressure,0,1));\n        node.style.setProperty('--o', o.toFixed(3));\n        if (State.reduceMotion) return;\n        // very subtle glow “breath”\n        if (Math.random()<0.02) node.style.filter = `drop-shadow(0 0 ${Math.random()<0.5?4:6}px color-mix(in oklab, currentColor 40%, transparent))`;\n      },\n      node\n    };\n  };\n  A.callout.meta = calloutMeta;\n\n  const graphMeta = { affinity:'gutters', complexity:5 };\n  A.graph = () => {\n    let cluster, nodes=[], edges=[]; return {\n      kind:'graph', cost:2, ...graphMeta,\n      mount(p){\n        cluster = el('div','mschf-graph',p);\n        const n = 4 + Math.floor(Math.random()*(/(loud|storm)/.test(State.mood)?8:6));\n        for (let i=0;i<n;i++){ const s=el('span','mschf-graph-node',cluster); s.style.setProperty('--x', `${Math.random()*100}vw`); s.style.setProperty('--y', `${Math.random()*100}vh`); nodes.push(s); }\n        const m = 2 + Math.floor(Math.random()*4);\n        for (let i=0;i<m;i++){ const e=el('i','mschf-graph-edge',cluster); e.style.setProperty('--x1', `${Math.random()*100}vw`); e.style.setProperty('--y1', `${Math.random()*100}vh`); e.style.setProperty('--x2', `${Math.random()*100}vw`); e.style.setProperty('--y2', `${Math.random()*100}vh`); edges.push(e); }\n      },\n      update(){\n        if (State.reduceMotion) return;\n        for (const s of nodes){\n          const x = parseFloat((s.style.getPropertyValue('--x')||'0vw')) || Math.random()*100;\n          const y = parseFloat((s.style.getPropertyValue('--y')||'0vh')) || Math.random()*100;\n          const nx = clamp(x + (Math.random()-.5)*.5*State.tempo, 0, 100);\n          const ny = clamp(y + (Math.random()-.5)*.5*State.tempo, 0, 100);\n          s.style.setProperty('--x', `${nx}vw`); s.style.setProperty('--y', `${ny}vh`);\n        }\n        if (Math.random()<0.015*State.tempo){\n          const e = pick(edges); if (e){ e.style.setProperty('--x2', `${Math.random()*100}vw`); e.style.setProperty('--y2', `${Math.random()*100}vh`); }\n        }\n      },\n      node:{ remove(){ cluster.remove(); } }\n    };\n  };\n  A.graph.meta = graphMeta;\n\n  const ringsMeta = { affinity:'anywhere', complexity:2 };\n  A.ringsDOM = () => { let node; return { kind:'rings', cost:1, ...ringsMeta, mount(p){ node = el('div','mschf-rings',p); if (State.reduceMotion) node.classList.add('static'); const s = 110 + Math.floor(Math.random()*200); css(node,{ left:`${10+Math.random()*80}%`, top:`${10+Math.random()*70}%`, width:s+'px', height:s+'px' }); }, node }; };\n  A.ringsDOM.meta = ringsMeta;\n  const topoMeta = { affinity:'anywhere', complexity:3 };\n  A.topoDOM = () => { let node; return { kind:'topo', cost:1, ...topoMeta, mount(p){ node=el('div','mschf-topo',p); node.style.setProperty('--rot', `${Math.floor((Math.random()-0.5)*24)}deg`); }, node }; };\n  A.topoDOM.meta = topoMeta;\n  const halftoneMeta = { affinity:'anywhere', complexity:3 };\n  A.halftone = () => { let node; return { kind:'halftone', cost:1, ...halftoneMeta, mount(p){ node=el('div','mschf-halftone '+pick(['tl','tr','bl','br']),p); }, node }; };\n  A.halftone.meta = halftoneMeta;\n\n  const perfMeta = { affinity:'gutters', complexity:2 };\n  A.perf = () => { let node; return { kind:'perf', cost:1, ...perfMeta, mount(p){ node=el('div','mschf-perf',p); node.dataset.side = pick(['top','bottom','left','right']); }, node }; };\n  A.perf.meta = perfMeta;\n\n  const starMeta = { affinity:'anywhere', complexity:4 };\n  A.starfieldDOM = () => { let node; return { kind:'stars', cost:1, ...starMeta, mount(p){ node=el('div','mschf-stars',p); node.style.setProperty('--density', `${0.12 + Math.random()*0.25}`); }, node }; };\n  A.starfieldDOM.meta = starMeta;\n\n  // Frame & stickers\n  const bracketsMeta = { affinity:'corners', complexity:1 };\n  A.brackets = () => {\n    let node; return {\n      kind:'brackets', cost:1, ...bracketsMeta,\n      mount(p){\n        node = el('div','mschf-brackets',p);\n        node.classList.add(pick(['tight','wide']));\n        const isArticle = !!document.querySelector('.prose,article,main .prose');\n        node.dataset.variant = (State.readingPressure>0.18 || isArticle) ? 'lite' : 'bold';\n        const pad = (node.classList.contains('wide')? (2 + Math.random()*2) : (5 + Math.random()*3));\n        const stroke = node.dataset.variant==='lite' ? 2 : 3;\n        node.style.setProperty('--pad', pad+'vmin');\n        node.style.setProperty('--b', stroke+'px');\n      },\n      update(){ if(!node) return; const base = node.dataset.variant==='lite' ? .12 : .18; const o = lerp(base*0.4, base, 1 - clamp(State.readingPressure,0,1)); node.style.setProperty('--o', o.toFixed(3)); },\n      node\n    };\n  };\n  A.brackets.meta = bracketsMeta;\n  const glitchMeta = { affinity:'gutters', complexity:3 };\n  A.glitch = () => { let node; return { kind:'glitch', cost:1, ...glitchMeta, mount(p){ node=el('div','mschf-glitch',p); if (State.reduceMotion) node.classList.add('static'); css(node,{ top:Math.floor(Math.random()*100)+'%', left:0, right:0 }); }, node }; };\n  A.glitch.meta = glitchMeta;\n  const watermarkMeta = { affinity:'header', complexity:2 };\n  A.watermark = () => {\n    let node, inner; const LEX = ['EFFUSION LABS','EXPERIMENTAL','INTERNAL','READ ONLY','NONCANON','SANDBOX','PROTOTYPE','ARCHIVE'];\n    const phrase = () => `${pick(LEX)} • ${pick(LEX)} • ${pick(LEX)} •`;\n    return {\n      kind:'watermark', cost:1, ...watermarkMeta,\n      mount(p){\n        node = el('div','mschf-watermark',p);\n        const isArticle = !!document.querySelector('.prose,article,main .prose');\n        const variant = (State.readingPressure>0.25 || isArticle) ? 'stripe' : pick(['stripe','full']);\n        node.dataset.variant = variant;\n        const rot = (Math.random()<.5? -1:1) * (12 + Math.random()*10);\n        const y = Math.round(8 + Math.random()*74);\n        const h = Math.round(26 + Math.random()*28);\n        node.style.setProperty('--rot', rot+'deg');\n        node.style.setProperty('--y', y+'%');\n        node.style.setProperty('--h', h+'px');\n        node.style.setProperty('--o', (/(loud|storm)/.test(State.mood)? .12 : .08).toString());\n        inner = document.createElement('span'); inner.className='mschf-wm-line';\n        inner.textContent = (phrase()+\" \").repeat(12);\n        node.appendChild(inner);\n      },\n      update(t){\n        if (!node) return; const base = parseFloat(getComputedStyle(node).getPropertyValue('--o')||'0.08')||0.08;\n        const o = lerp(base*0.35, base, 1 - clamp(State.readingPressure,0,1)); node.style.opacity = o.toFixed(3);\n        if (State.reduceMotion) return;\n        const dir = node.dataset.dir || (node.dataset.dir = (Math.random()<.5? '1':'-1'));\n        const speed = (State.tiers.lg? 18:12) * (/(studio|loud)/.test(State.mood)?1.3:1.0);\n        const tx = ((t/1000) * speed * (dir==='1'?1:-1)) % 100; if (inner) inner.style.transform = `translateX(${tx.toFixed(1)}px)`;\n      },\n      node\n    };\n  };\n  A.watermark.meta = watermarkMeta;\n  const flowersMeta = { affinity:'anywhere', complexity:2 };\n  A.flowers = () => { const nodes=[]; return { kind:'flowers', cost:1, ...flowersMeta, mount(p){ const n=1+Math.floor(Math.random()*(/(loud|storm)/.test(State.mood)?2:1)); for(let i=0;i<n;i++){ const fl=el('div','mschf-flower',p); const s=34+Math.floor(Math.random()*26), x=10+Math.floor(Math.random()*80), y=10+Math.floor(Math.random()*70); css(fl,{ width:s+'px', height:s+'px', left:x+'%', top:y+'%', transform:`rotate(${Math.floor((Math.random()-0.5)*160)}deg)` }); nodes.push(fl);} }, node:{ remove(){ nodes.forEach(n=>n.remove()); } } }; };\n  A.flowers.meta = flowersMeta;\n  const holoMeta = { affinity:'gutters', complexity:4 };\n  A.holo = () => { let node; return { kind:'holo', cost:1, ...holoMeta, mount(p){ node=el('div','mschf-holo',p); if (State.reduceMotion) node.classList.add('static'); }, node }; };\n  A.holo.meta = holoMeta;\n  const regMeta = { affinity:'corners', complexity:1 };\n  A.reg = () => { const nodes=[]; return { kind:'reg', cost:1, ...regMeta, mount(p){ ['tl','tr','bl','br'].forEach(pos=>nodes.push(el('div','mschf-reg '+pos,p))); }, node:{ remove(){ nodes.forEach(n=>n.remove()); } } }; };\n  A.reg.meta = regMeta;\n  const dimsMeta = { affinity:'anywhere', complexity:1 };\n  A.dims = () => {\n    let node, label; return {\n      kind:'dims', cost:1, ...dimsMeta,\n      mount(p){\n        node = el('div','mschf-dims',p);\n        // Prefer top/bottom gutters to avoid center text\n        const edgeTop = Math.random() < 0.5;\n        const y = edgeTop ? (8 + Math.random()*12) : (78 + Math.random()*12);\n        const x1 = 6 + Math.floor(Math.random()*24);\n        const span = 24 + Math.floor(Math.random()*32);\n        const x2 = Math.min(92, x1 + span);\n        node.style.setProperty('--x1', `${x1}vw`);\n        node.style.setProperty('--x2', `${x2}vw`);\n        node.style.setProperty('--y', `${y}vh`);\n        node.style.setProperty('--o', (/(loud|storm)/.test(State.mood)? .26 : .22).toString());\n        label = document.createElement('em');\n        label.className = 'mschf-dims-label';\n        label.textContent = `${Math.abs(x2 - x1)}vw`;\n        node.appendChild(label);\n        el('span','',node); // right tick\n      },\n      update(t){\n        if (!node) return;\n        const base = /(studio|loud)/.test(State.mood) ? .22 : .18;\n        const o = lerp(base*0.6, base, 1 - clamp(State.readingPressure,0,1));\n        node.style.setProperty('--o', o.toFixed(3));\n        if (State.reduceMotion || !label) return;\n        const s = 0.98 + Math.sin(t/1200)*0.02; // soft breathing\n        label.style.setProperty('--s', s.toFixed(3));\n      },\n      node\n    };\n  };\n  A.dims.meta = dimsMeta;\n  const stickersMeta = { affinity:'gutters', complexity:3 };\n  A.stickers = () => {\n    let cluster; return {\n      kind:'stickers', cost:1, ...stickersMeta,\n      mount(p){\n        cluster = el('div','mschf-stickers',p);\n        const corner = this.corner || pick(['br','bl','tr','tl']); const off = 18 + Math.floor(Math.random()*18);\n        const s={}; if (corner.includes('b')) s.bottom=off+'px'; else s.top=off+'px'; if (corner.includes('r')) s.right=off+'px'; else s.left=off+'px'; css(cluster,s);\n        const badges = ['ALPHA','BETA','RC1','SIGNED','VOID','UNLOCKED','PASS','LAB','SIM','ARCHIVE','SANDBOX','RAG','EVAL','GRAPH','SPARK','VECTOR','EMBED','SPECIMEN','PROTO'];\n        const n = 2 + Math.floor(Math.random()*3);\n        for (let i=0;i<n;i++){\n          const b = el('span','mschf-badge',cluster); b.textContent = pick(badges);\n          pick([()=>{ b.style.fontSize='10px'; b.style.padding='5px 7px'; },()=>{ b.style.fontSize='11px'; b.style.padding='6px 8px'; },()=>{ b.style.fontSize='12px'; b.style.padding='7px 9px'; }])();\n          b.style.setProperty('--rx', `${Math.floor((Math.random()-0.5)*16)}deg`);\n          b.style.setProperty('--offx', `${Math.floor((Math.random()-0.5)*14)}px`);\n          b.style.setProperty('--offy', `${Math.floor((Math.random()-0.5)*10)}px`);\n          if (Math.random() < .22) b.style.boxShadow='0 0 0 1px color-mix(in oklab, currentColor 35%, transparent), 0 10px 18px rgba(0,0,0,.35)';\n        }\n      },\n      node:{ remove(){ cluster.remove(); } }\n    };\n  };\n  A.stickers.meta = stickersMeta;\n\n  // ————————————————————————————————————————\n  // Frame Enhancements — subtle, procedural, autonomous\n  // ————————————————————————————————————————\n  const edgeMeta = { affinity:'anywhere', complexity:2 };\n  A.edgeGlow = () => {\n    let nodes = [];\n    function make(pos){\n      const n = el('div', `mschf-edge mschf-edge-${pos}` , State.domLayer);\n      return n;\n    }\n    return {\n      kind:'edgeGlow', cost:1, ...edgeMeta,\n      mount(p){ nodes = ['top','right','bottom','left'].map(make); },\n      update(t){\n        const pressure = State.readingPressure || 0; // 0..1\n        const base = /(loud|storm|studio)/.test(State.mood) ? 0.11 : 0.07;\n        const o = Math.max(0.03, base * (1 - pressure*0.8));\n        const k = (State.tempo || 1) * (State.tiers.lg ? 1 : 0.8);\n        const phase = (t/1000) * 0.2 * k; // slow drift\n        for (const n of nodes){\n          n.style.setProperty('--o', o.toFixed(3));\n          n.style.setProperty('--p', (phase % 1).toFixed(3));\n        }\n      },\n      node:{ remove(){ nodes.forEach(n=>n.remove()); } }\n    };\n  };\n  A.edgeGlow.meta = edgeMeta;\n\n  const pipsMeta = { affinity:'corners', complexity:1 };\n  A.cornerPips = () => {\n    const nodes = [];\n    return {\n      kind:'pips', cost:1, ...pipsMeta,\n      mount(p){\n        ['tl','tr','bl','br'].forEach(c=>{\n          const n = el('div', `mschf-pip mschf-pip-${c}`, p);\n          nodes.push(n);\n        });\n      },\n      update(t){\n        if (State.reduceMotion) return;\n        const beat = (Math.sin(t/900) + 1)/2; // 0..1\n        const s = 0.9 + beat*0.15;\n        for (const n of nodes){ n.style.transform = `scale(${s.toFixed(3)})`; }\n      },\n      node:{ remove(){ nodes.forEach(n=>n.remove()); } }\n    };\n  };\n  A.cornerPips.meta = pipsMeta;\n\n  // ————————————————————————————————————————\n  // Orchestration\n  // ————————————————————————————————————————\n  function composeInitial() {\n    DEBUG && group('composeInitial');\n    C.composeInitial++;\n    DEBUG && log('style/mood/density', { style: State.style, mood: State.mood, density: State.density, tiers: { ...State.tiers }, caps: { ...State.caps } });\n    // Scaffold (calm by default)\n    mount(A.grid(),    'scaffold');\n    mount(A.frame(),   'scaffold');\n    mount(A.corners(), 'scaffold');\n    mount(A.rulers(),  'scaffold');\n    // Removed moving scanline by default for readability\n\n    const isArticle = !!document.querySelector('.prose,article,main .prose');\n\n    const waves = {\n      structural: () => { spawnLab(1,2); spawnFrame(1,2); if (!isArticle) spawnEphemera(1,2); },\n      collage:    () => { spawnEphemera(1,3); spawnLab(1,2); spawnFrame(1,2); },\n      playful:    () => { spawnEphemera(2,3); spawnFrame(1,2); }\n    };\n    (waves[State.style] || waves.structural)();\n    const kindsSummary = (fam) => { const m = Object.create(null); for (const a of State.families[fam]) m[a.kind||'unknown']=(m[a.kind||'unknown']||0)+1; return m; };\n    DEBUG && log('post-compose sizes', {\n      scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size,\n      nodeCount: State.nodeCount,\n      kinds: { ephemera: kindsSummary('ephemera'), lab: kindsSummary('lab'), frame: kindsSummary('frame') }\n    });\n    DEBUG && groupEnd();\n  }\n\n  function spawnEphemera(min,max){\n    const bag = [A.tape, A.stamp, A.quotes, A.plate, A.specimen];\n    const pool = State.readingPressure > 0.25 ? bag.filter(f => (f.meta?.complexity || 1) <= 2) : bag;\n    const n = Math.floor(lerp(min, max, State.density));\n    for (let i=0;i<n;i++){ const fn = pick(pool.length?pool:bag); mount(fn(), 'ephemera'); }\n  }\n  function spawnLab(min,max){\n    const gpuOK = !!State.app && !State.reduceData;\n    const base = [A.callout, A.graph, A.perf];\n    const domExtras = [State.config.rings? A.ringsDOM : null, State.config.topo? A.topoDOM : null, A.halftone, A.starfieldDOM].filter(Boolean);\n    const bag = gpuOK ? base : base.concat(domExtras);\n    const pool = State.readingPressure > 0.25 ? bag.filter(f => (f.meta?.complexity || 1) <= 3) : bag;\n    const n = Math.floor(lerp(min, max, State.density));\n    for (let i=0;i<n;i++){ const fn = pick(pool.length?pool:bag); mount(fn(), 'lab'); }\n  }\n  function spawnFrame(min,max){\n    // Calm set plus tasteful autonomous accents\n    const bag = [A.brackets, A.watermark, A.reg, A.dims, A.stickers, A.edgeGlow, A.cornerPips];\n    const pool = State.readingPressure > 0.25 ? bag.filter(f => (f.meta?.complexity || 1) <= 2) : bag;\n    const n = Math.floor(lerp(min, max, State.density));\n    for (let i=0;i<n;i++){\n      const candidates = (pool.length?pool:bag).slice();\n      let placed = false;\n      for (let t=0;t<candidates.length && !placed; t++){\n        const idx = Math.floor(Math.random()*candidates.length);\n        const fn = candidates.splice(idx,1)[0];\n        placed = !!mount(fn(), 'frame');\n      }\n    }\n  }\n\n  function recompose(){\n    DEBUG && group('recompose');\n    C.recompose++;\n    resetOccupancy(); computeContext();\n    const kindsSummary = (fam) => {\n      const m = Object.create(null);\n      for (const a of State.families[fam]) m[a.kind||'unknown'] = (m[a.kind||'unknown']||0)+1;\n      return m;\n    };\n    const sizes = {\n      ephemera: State.families.ephemera.size,\n      lab:      State.families.lab.size,\n      frame:    State.families.frame.size,\n    };\n    DEBUG && log('pre-prune sizes', {\n      scaffold: State.families.scaffold.size,\n      ephemera: sizes.ephemera,\n      lab:      sizes.lab,\n      frame:    sizes.frame,\n      caps: { ...State.caps }, density: State.density, readingPressure: State.readingPressure\n    });\n\n    // Compute stable targets per family based on caps, density, and reading pressure.\n    const d = clamp(State.density, 0.2, 0.9);\n    const pressureMod = State.readingPressure > 0.25 ? 0.6 : 1.0; // quieter when reading\n    const want = {\n      ephemera: Math.min(State.caps.ephemera, Math.round(lerp(1, State.caps.ephemera, d) * pressureMod)),\n      lab:      Math.min(State.caps.lab,      Math.round(lerp(1, State.caps.lab,      d) * pressureMod)),\n      frame:    Math.min(State.caps.frame,    Math.round(lerp(1, State.caps.frame,    d) * pressureMod)),\n    };\n\n    // Prefer to shed high-complexity actors when above target.\n    for (const fam of ['ephemera','lab','frame']){\n      const have = sizes[fam];\n      const needToRemove = Math.max(0, have - want[fam]);\n      if (!needToRemove) continue;\n      const actors = Array.from(State.families[fam]).sort((a,b)=>(b.complexity||1)-(a.complexity||1));\n      for (let i=0;i<needToRemove;i++){ const a = actors[i]; if (a) retire(a); }\n      sizes[fam] -= needToRemove;\n    }\n\n    // Top up gently to targets (idempotent: does nothing once at/over target)\n    const addEphemera = Math.max(0, want.ephemera - sizes.ephemera);\n    const addLab      = Math.max(0, want.lab      - sizes.lab);\n    const addFrame    = Math.max(0, want.frame    - sizes.frame);\n    if (addEphemera) spawnEphemera(addEphemera, addEphemera);\n    if (addLab)      spawnLab(addLab, addLab);\n    if (addFrame)    spawnFrame(addFrame, addFrame);\n\n    DEBUG && log('post-recompose sizes', {\n      scaffold: State.families.scaffold.size,\n      ephemera: State.families.ephemera.size,\n      lab:      State.families.lab.size,\n      frame:    State.families.frame.size,\n      nodeCount: State.nodeCount,\n      kinds: {\n        ephemera: kindsSummary('ephemera'),\n        lab: kindsSummary('lab'),\n        frame: kindsSummary('frame'),\n      }\n    });\n    DEBUG && groupEnd();\n  }\n\n  function rareMoment(){\n    if (State.reduceMotion || State.tiers.xs) return;\n    C.rare++;\n    DEBUG && log('rareMoment');\n    mount(A.holo(), 'frame');\n    for (let i=0;i<2;i++) mount(A.glitch(), 'frame');\n    mount(A.tape(), 'ephemera');\n    setTimeout(()=>mount(A.tape(),'ephemera'), 160);\n  }\n\n  function degradeDensity(){\n    // drop some actors and reduce target density\n    const fams = ['lab','frame','ephemera'];\n    State.density = Math.max(.18, State.density - 0.06);\n    for (const fam of fams) {\n      const n = Math.ceil(State.families[fam].size * 0.3);\n      for (let i=0;i<n;i++){ const a = State.families[fam].values().next().value; if (a) retire(a); }\n      if (!State.fps.bad) break;\n    }\n  }\n\n  // ————————————————————————————————————————\n  // Scheduler\n  // ————————————————————————————————————————\n  function tick(t){\n    if (State.paused) return;\n    requestAnimationFrame(tick);\n    const dt = t - (State._t || t); State._t = t;\n\n    // FPS sentinel (sooner + gentler)\n    const S = State.fps.samples; S.push(dt); if (S.length>18) S.shift();\n    if (S.length===18){\n      const avg = S.reduce((a,b)=>a+b,0)/S.length; State.fps.bad = avg>24; // ~ < 41 FPS\n      if (State.fps.bad) degradeDensity();\n    }\n\n    if (t - State.beats.last > State.beats.dur) { State.beats.last = t; C.beats++; DEBUG && (C.beats % 20 === 0) && log('beat', { beats: C.beats, bars: C.bars }); }\n    if (t - State.bars.last  > State.bars.dur)  {\n      State.bars.last = t; C.bars++;\n      DEBUG && log('bar tick', { bars: C.bars, mood: State.mood, density: State.density, actors: State.actors.size });\n      const mode = State.config.recompose;\n      if (mode === 'auto') {\n        if (Math.random()<.7) applyMood(nextMood(State.mood));\n        recompose();\n        if (State.config.rare && Math.random()<.06) rareMoment();\n      } else if (mode === 'once') {\n        if (!State._didRecompose) { recompose(); State._didRecompose = true; }\n      } else {\n        // 'off' → no periodic recomposition\n      }\n    }\n\n    for (const a of Array.from(State.actors)) {\n      try { a.update && a.update(t, dt); } catch {}\n      if (a.dead) retire(a);\n    }\n    GPU.step(t);\n\n    // Debug dev-labels (throttled)\n    // enforce pass-through unless picking\n    try {\n      if (State.root) State.root.style.pointerEvents = State._picking ? 'auto' : 'none';\n      if (State.domLayer) State.domLayer.style.pointerEvents = State._picking ? 'auto' : 'none';\n      if (State.labelLayer) State.labelLayer.style.pointerEvents = 'none';\n      if (State.app?.canvas) State.app.canvas.style.pointerEvents = 'none';\n    } catch {}\n\n    // GPU self-heal: if desired but lost/absent, try to reinit occasionally\n    try {\n      const wantGPU = !!(State.config.gpuRings || State.config.gpuTopo || State.config.gpuStars);\n      if (wantGPU && (!State.app || State._gpuLost)){\n        const due = !State._gpuRetryAt || t > State._gpuRetryAt;\n        if (due){\n          State._gpuRetryAt = t + 4000; // backoff\n          GPU.init().then(app=>{ if(app){ State._gpuLost=false; DEBUG&&log('GPU reinit ok'); } });\n        }\n      }\n    } catch {}\n\n    if (State.debug.labelsOn) { try { updateDevLabels(); } catch {} }\n    if (State.debug.hudOn)    { try { updateHUD(); } catch {} }\n  }\n\n  // ————————————————————————————————————————\n  // Observers & context\n  // ————————————————————————————————————————\n  function updateDevLabels(){\n    if (!State.labelLayer) return;\n    const seen = new Set();\n    for (const a of State.actors){\n      if (!a || !a.node || !a.node.getBoundingClientRect) continue;\n      const id = a._id;\n      seen.add(id);\n      let lab = State._labels.get(id);\n      if (!lab){\n        lab = document.createElement('div');\n        lab.className = 'mschf-devlabel';\n        lab.style.cssText = 'position:fixed;z-index:999999;font:700 10px/1 ui-monospace,Menlo,monospace;letter-spacing:.06em;color:#00ff41;background:rgba(0,0,0,.6);border:1px solid rgba(0,255,65,.6);padding:2px 4px;border-radius:4px;pointer-events:none;user-select:none;';\n        State.labelLayer.appendChild(lab);\n        State._labels.set(id, lab);\n      }\n      const r = a.node.getBoundingClientRect();\n      lab.style.left = Math.round(r.left + 2) + 'px';\n      lab.style.top  = Math.round(r.top  + 2) + 'px';\n      const txt = `#${id} ${a.kind||'?'} @${Object.entries(State.families).find(([,set])=>set.has(a))?.[0]||'?'}${(a.node?.textContent?.trim()?` — ${a.node.textContent.trim().slice(0,18)}`:'')}`;\n      lab.textContent = txt;\n      lab.hidden = false;\n    }\n    // hide labels for retired actors\n    for (const [id, lab] of State._labels){ if (!seen.has(id)) { try{ lab.remove(); }catch{} State._labels.delete(id); } }\n  }\n\n  // Alt-click picking without toggling pointer-events globally\n  function pickFromPoint(x, y){\n    try {\n      const root = State.domLayer || document;\n      const nodes = [...root.querySelectorAll('[data-mschf=\"1\"]')];\n      const hits = nodes.filter(n=>{ const r=n.getBoundingClientRect(); return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom; });\n      const target = hits[hits.length-1]; // last in DOM order ≈ on top\n      if (!target) return false;\n      const id = +target.dataset.mschfId; const kind = target.dataset.mschfKind; const family = target.dataset.mschfFamily;\n      const r = target.getBoundingClientRect();\n      const a = [...State.actors].find(x=>x._id===id);\n      console.log('[MSCHF] pick@point', { id, kind, family, bbox:{x:Math.round(r.x),y:Math.round(r.y),w:Math.round(r.width),h:Math.round(r.height)}, text:(target.textContent||'').trim(), node:target, actor:a });\n      target.classList.add('mschf-highlight'); setTimeout(()=>target.classList.remove('mschf-highlight'), 2000);\n      return true;\n    } catch (e) { DEBUG && warn('pickFromPoint error', e); return false; }\n  }\n\n  function updateHUD(){\n    if (!State.hud) return;\n    State.hud.style.display = 'block';\n    const sizes = {\n      scaffold: State.families.scaffold.size,\n      ephemera: State.families.ephemera.size,\n      lab: State.families.lab.size,\n      frame: State.families.frame.size,\n    };\n    const line1 = `bars:${C.bars} beats:${C.beats} mood:${State.mood} d:${State.density.toFixed(2)}`;\n    const line2 = `scaf:${sizes.scaffold} eph:${sizes.ephemera} lab:${sizes.lab} frame:${sizes.frame}`;\n    const line3 = `actors:${State.actors.size} nodes:${State.nodeCount}`;\n    // brief legend of kinds by frame/ephemera\n    const kinds = (fam)=>{\n      const m = Object.create(null); for (const a of State.families[fam]) m[a.kind||'?']=(m[a.kind||'?']||0)+1; return Object.entries(m).map(([k,v])=>`${k}×${v}`).join(' ');\n    };\n    const line4 = `@ephemera ${kinds('ephemera')}`;\n    const line5 = `@frame ${kinds('frame')}`;\n    State.hud.textContent = `${line1}\\n${line2}\\n${line3}\\n${line4}\\n${line5}`;\n  }\n  function wireSections(){\n    const hero = document.querySelector('.hero,[data-component~=\"hero\"],section[id*=\"hero\"]');\n    const cta  = document.querySelector('.map-cta,[class*=\"map-cta\"],[data-component~=\"map-cta\"]');\n    const feed = document.querySelector('.work-feed,[data-component~=\"work-feed\"]');\n    DEBUG && log('wireSections', { hero: !!hero, cta: !!cta, feed: !!feed });\n\n    // Observe once per section: prevent repeated mounts when crossing thresholds\n    const io = new IntersectionObserver((entries)=>{\n      for (const e of entries){\n        if (!e.isIntersecting) continue;\n        // Skip if we've already handled this target\n        if (e.target?.dataset?.mschfSeen === '1') { io.unobserve(e.target); continue; }\n        C.io++;\n        DEBUG && log('io fired', { which: e.target === hero ? 'hero' : e.target === cta ? 'cta' : e.target === feed ? 'feed' : 'unknown', count: C.io });\n        if (hero && e.target===hero) { if (State.config.rings) mount(A.ringsDOM(),'lab'); mount(A.quotes(),'ephemera'); }\n        if (cta && e.target===cta)   { mount(A.plate(),'ephemera'); if (State.config.rare) rareMoment(); }\n        if (feed && e.target===feed) { mount(A.stickers(),'frame'); mount(A.dims(),'frame'); }\n\n        // Mark handled and stop observing to avoid duplicate mounts\n        try { e.target.dataset.mschfSeen = '1'; io.unobserve(e.target); } catch {}\n      }\n    }, { rootMargin:'0px 0px -20% 0px', threshold:[0.25, 0.6] });\n\n    [hero, cta, feed].filter(Boolean).forEach(n=>io.observe(n));\n  }\n\n  // ————————————————————————————————————————\n  // Visibility & events\n  // ————————————————————————————————————————\n  function onVisibility(){\n    State.visible = !document.hidden;\n    if (!State.visible) State.paused = true;\n    else { State.paused = false; State.beats.last = now(); State.bars.last = now(); DEBUG && log('visibility: resume'); requestAnimationFrame(tick); }\n  }\n\n  // Auto-enable Alt-click picking in DEBUG\n  const _autoPickClick = (ev) => {\n    if (!DEBUG || !State.debug.autoPick) return;\n    if (!ev.altKey) return; // hold Alt/Option to pick\n    // don't let the page handle this click\n    ev.preventDefault(); ev.stopPropagation();\n    pickFromPoint(ev.clientX, ev.clientY);\n  };\n  const _autoPickKey = (ev) => {\n    if (!DEBUG || !State.debug.autoPick || !State.root) return;\n    if (ev.type === 'keydown' && ev.key === 'Alt') State.root.style.cursor = 'crosshair';\n    if (ev.type === 'keyup'   && ev.key === 'Alt') State.root.style.cursor = '';\n  };\n\n  // ————————————————————————————————————————\n  // Boot\n  // ————————————————————————————————————————\n  async function boot(){\n    DEBUG && log('boot()');\n    mountRoot(); computeTiers(); computeContext(); resetOccupancy();\n\n    // GPU init (LG only, not reduced-data, and avoid truly weak CPUs)\n    const weakCPU = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;\n    if (!State.tiers.xs && !State.tiers.sm && !State.reduceData && !weakCPU) {\n      State.app = await GPU.init();\n    }\n\n    // Prefer structural on obvious reading pages\n    if (document.querySelector('.prose,article,main .prose') && State.style === 'collage') State.style = 'structural';\n\n    applyMood(State.mood);\n    composeInitial();\n    wireSections();\n    // In 'once' mode, schedule a single recompose shortly after initial compose\n    if (State.config.recompose === 'once') {\n      setTimeout(() => { if (!State._didRecompose) { try { recompose(); } finally { State._didRecompose = true; } } }, 600);\n    }\n    // Bind debug auto-pick handlers (Alt-click)\n    try {\n      document.addEventListener('click', _autoPickClick, true);\n      document.addEventListener('keydown', _autoPickKey, true);\n      document.addEventListener('keyup', _autoPickKey, true);\n    } catch {}\n    requestAnimationFrame(tick);\n  }\n\n  // Events\n  addEventListener('resize', () => { computeTiers(); computeContext(); resetOccupancy(); });\n  document.addEventListener('visibilitychange', onVisibility, false);\n\n  // Reduced motion/data immediate adjustments\n  if (State.reduceMotion) State.density = Math.min(State.density, .45);\n  if (State.reduceData)   State.density = Math.min(State.density, .4);\n\n  // Start\n  if (document.readyState === 'complete' || document.readyState === 'interactive') requestAnimationFrame(boot);\n  else document.addEventListener('DOMContentLoaded', () => requestAnimationFrame(boot));\n\n  // ————————————————————————————————————————\n  // Console Controls\n  // ————————————————————————————————————————\n  window.__mschfOff = () => { localStorage.setItem('mschf:off','1'); try{ State.root?.remove(); }catch{} };\n  window.__mschfOn  = () => { localStorage.removeItem('mschf:off'); location.reload(); };\n  window.__mschfPulse = () => rareMoment();\n  window.__mschfMood  = (m) => { if (['calm','lite','bold','loud','storm','studio'].includes(m)) applyMood(m); };\n  window.__mschfDensity = (x) => { State.density = clamp(+x||State.density, .1, .9); recompose(); };\n  window.__mschfMask = (on=1) => { State.gpu.maskOn = !!(+on); GPU.updateMask(); };\n  window.__mschfAlpha = (x) => { State.alpha = clamp(+x||State.alpha, 0.3, 1.0); if(State.root) State.root.style.opacity = State.alpha; };\n  window.__mschfDebug = (on=1) => { localStorage.setItem('mschf:debug', on? '1':'0'); location.reload(); };\n  window.__mschfHUD = (on=1) => {\n    State.debug.hudOn = !!(+on);\n    if (State.debug.hudOn) { updateHUD(); }\n    else if(State.hud) { State.hud.textContent=''; State.hud.style.display='none'; }\n  };\n  window.__mschfAutoPick = (on=1) => { State.debug.autoPick = !!(+on); };\n  window.__mschfCull = (kind='rings') => { const culled=[]; for (const a of Array.from(State.actors)){ if ((a.kind||'')===kind){ retire(a); culled.push(a._id); } } console.log('[MSCHF] culled', kind, culled); return culled.length; };\n  window.__mschfToggle = (what, on=1) => {\n    const enable = !!(+on);\n    if (what==='rings') { State.config.rings=enable; if (!enable) __mschfCull('rings'); else recompose(); return; }\n    if (what==='topo')  { State.config.topo=enable;  if (!enable) __mschfCull('topo');  else recompose(); return; }\n    if (!State.app || !GPU.stage) { console.warn('[MSCHF] GPU not active'); return; }\n    const PIXI = globalThis.PIXI;\n    if (what==='gpuRings') {\n      State.config.gpuRings = enable;\n      if (enable && !GPU.rings && PIXI) { GPU.rings = GPU.makeRings(PIXI); GPU.stage.addChild(GPU.rings.container); }\n      if (!enable && GPU.rings) { GPU.rings.container.removeFromParent(); GPU.rings=null; }\n      return;\n    }\n    if (what==='gpuTopo') {\n      State.config.gpuTopo = enable;\n      if (enable && !GPU.topo && PIXI) { GPU.topo = GPU.makeTopo(PIXI); GPU.stage.addChild(GPU.topo.container); }\n      if (!enable && GPU.topo) { GPU.topo.container.removeFromParent(); GPU.topo=null; }\n      return;\n    }\n    if (what==='gpuStars') {\n      State.config.gpuStars = enable;\n      if (enable && !GPU.starfield && PIXI) { GPU.starfield = GPU.makeStars(PIXI); GPU.stage.addChild(GPU.starfield.container); }\n      if (!enable && GPU.starfield) { GPU.starfield.container.removeFromParent(); GPU.starfield=null; }\n      return;\n    }\n  };\n  // Turn on live dev labels: __mschfLabels(1)\n  window.__mschfLabels = (on=1) => { State.debug.labelsOn = !!(+on); if (on) updateDevLabels(); else { for (const [,lab] of State._labels){ try{ lab.remove(); }catch{} } State._labels.clear(); } };\n  // Dump actors to console (optionally filter by '@family' or 'kind')\n  window.__mschfDump = (filter='') => {\n    const norm = String(filter||'').trim();\n    const out = [];\n    for (const a of State.actors){\n      const fam = Object.entries(State.families).find(([,set])=>set.has(a))?.[0]||'?';\n      if (!norm || (norm.startsWith('@') && norm.slice(1)===fam) || (!norm.startsWith('@') && (a.kind||'')===norm)){\n        const r = a.node?.getBoundingClientRect?.();\n        out.push({ id:a._id, kind:a.kind, family:fam, complexity:a.complexity||1, text:(a.node?.textContent||'').trim().slice(0,48), bbox:r?{x:Math.round(r.x),y:Math.round(r.y),w:Math.round(r.width),h:Math.round(r.height)}:null, node:a.node });\n      }\n    }\n    console.table(out);\n    return out;\n  };\n  // Highlight matches for a few seconds: __mschfSelect('stamp') or __mschfSelect('@frame') or __mschfSelect('*')\n  window.__mschfSelect = (q='*', seconds=2) => {\n    const root = State.domLayer || document;\n    let sel = [];\n    if (q==='*') sel = [...root.querySelectorAll('[data-mschf=\"1\"]')];\n    else if (q.startsWith('@')) sel = [...root.querySelectorAll(`[data-mschf-family=\"${q.slice(1)}\"]`)];\n    else sel = [...root.querySelectorAll(`[data-mschf-kind=\"${q}\"]`)];\n    sel.forEach(n=>n.classList.add('mschf-highlight'));\n    setTimeout(()=> sel.forEach(n=>n.classList.remove('mschf-highlight')), seconds*1000);\n    return sel.length;\n  };\n  // Find overlay nodes containing text (e.g., 'READ ONLY') and highlight\n  window.__mschfFind = (text, seconds=3) => {\n    const t = String(text||'').toLowerCase(); if (!t) return 0;\n    const nodes = [...(State.domLayer||document).querySelectorAll('[data-mschf=\"1\"]')].filter(n => (n.textContent||'').toLowerCase().includes(t));\n    nodes.forEach(n=>n.classList.add('mschf-highlight'));\n    setTimeout(()=> nodes.forEach(n=>n.classList.remove('mschf-highlight')), seconds*1000);\n    console.log('[MSCHF] __mschfFind', t, nodes);\n    return nodes.length;\n  };\n  // Click-to-inspect overlay: __mschfPick(1) then click a visual\n  window.__mschfPick = (on=1, timeoutMs=5000) => {\n    const enable = !!(+on);\n    const layer = State.domLayer; if (!layer) return false;\n    State._picking = enable;\n    layer.style.cursor = enable ? 'crosshair' : '';\n    const handler = (ev) => {\n      const target = ev.target.closest('[data-mschf=\"1\"]');\n      if (!target) return;\n      ev.preventDefault(); ev.stopPropagation();\n      const id = +target.dataset.mschfId;\n      const a = [...State.actors].find(x=>x._id===id);\n      const fam = Object.entries(State.families).find(([,set])=>set.has(a))?.[0]||'?';\n      const r = target.getBoundingClientRect();\n      console.log('[MSCHF] pick', { id:a?._id, kind:a?.kind, family:fam, text:(target.textContent||'').trim(), bbox:{x:Math.round(r.x),y:Math.round(r.y),w:Math.round(r.width),h:Math.round(r.height)}, node:target, actor:a });\n      target.classList.add('mschf-highlight'); setTimeout(()=>target.classList.remove('mschf-highlight'), 2000);\n      // auto-exit after one pick\n      if (State._picking) { State._picking=false; layer.style.cursor=''; }\n    };\n    if (enable) {\n      layer.addEventListener('click', handler, { capture:true, passive:false });\n      State._pickHandler = handler;\n      if (timeoutMs>0) setTimeout(()=>{ if (State._picking) { State._picking=false; layer.style.cursor=''; } }, timeoutMs);\n    } else if (State._pickHandler) {\n      layer.removeEventListener('click', State._pickHandler, { capture:true });\n      State._pickHandler=null;\n    }\n    return enable;\n  };\n  window.__mschfRecompose = (mode='auto') => { State.config.recompose = String(mode).toLowerCase(); };\n  window.__mschfRare = (on=1) => { State.config.rare = !!(+on); };\n  window.__mschfStats = () => ({ counters: { ...C }, sizes: {\n    scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size\n  }, nodeBudget: State.nodeBudget, nodeCount: State.nodeCount, caps: { ...State.caps }, density: State.density, readingPressure: State.readingPressure, mood: State.mood, visible: State.visible });\n})();\n",
  "src/assets/js/footnote-nav.js": "// /assets/js/footnote-nav.js\n(function () {\n  \"use strict\";\n\n  // --- Config ---------------------------------------------------------------\n  var HIGHLIGHT_MS = 2200; // matches CSS @keyframes footnote-highlight duration\n  var EXTRA_OFFSET_PX = 16; // small breathing room under sticky header\n\n  // --- Header height / scroll margin ---------------------------------------\n  function getHeaderEl() {\n    return (\n      document.querySelector(\"[data-site-header]\") ||\n      document.querySelector('[role=\"banner\"]') ||\n      document.querySelector(\"header.site-header\") ||\n      document.querySelector(\"body > header\") ||\n      document.querySelector(\"header\")\n    );\n  }\n\n  function readCssHeaderHeightVar() {\n    var v = getComputedStyle(document.documentElement).getPropertyValue(\n      \"--header-height\"\n    );\n    var n = parseFloat(v);\n    return Number.isFinite(n) ? n : null;\n  }\n\n  function calculateHeaderHeight() {\n    var fromVar = readCssHeaderHeightVar();\n    if (fromVar != null) return Math.ceil(fromVar);\n\n    var header = getHeaderEl();\n    if (!header) return 80 + EXTRA_OFFSET_PX;\n\n    var rect = header.getBoundingClientRect();\n    return Math.ceil(rect.height) + EXTRA_OFFSET_PX;\n  }\n\n  function setHeaderHeightVar(px) {\n    document.documentElement.style.setProperty(\"--header-height\", px + \"px\");\n  }\n\n  function updateScrollMargin() {\n    setHeaderHeightVar(calculateHeaderHeight());\n  }\n\n  // Throttle resize to rAF\n  var resizeRaf = 0;\n  function onResize() {\n    if (resizeRaf) return;\n    resizeRaf = requestAnimationFrame(function () {\n      resizeRaf = 0;\n      updateScrollMargin();\n    });\n  }\n\n  // Also react if the header itself resizes\n  function watchHeader() {\n    var header = getHeaderEl();\n    if (!(\"ResizeObserver\" in window) || !header) return;\n    var ro = new ResizeObserver(updateScrollMargin);\n    ro.observe(header);\n  }\n\n  // --- Scrolling + highlighting --------------------------------------------\n  function prefersReducedMotion() {\n    return (\n      window.matchMedia &&\n      window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\n    );\n  }\n\n  function scrollToTarget(target, opts) {\n    if (!target) return;\n    var headerHeight = calculateHeaderHeight();\n    var rect = target.getBoundingClientRect();\n    var top = window.pageYOffset + rect.top - headerHeight;\n    var behavior = prefersReducedMotion() ? \"auto\" : \"smooth\";\n    window.scrollTo({ top: Math.max(0, top), behavior: behavior });\n\n    if (!(opts && opts.skipHistory)) {\n      var id = target.id ? \"#\" + target.id : \"\";\n      if (id && id !== location.hash) {\n        try {\n          history.pushState(null, \"\", id);\n        } catch (_) {}\n      }\n    }\n    applyHighlight(target);\n  }\n\n  function applyHighlight(target) {\n    // Focus safely without permanently mutating tabindex\n    var hadTabindex = target.hasAttribute(\"tabindex\");\n    var prevTabindex = target.getAttribute(\"tabindex\");\n    if (!hadTabindex) target.setAttribute(\"tabindex\", \"-1\");\n    target.focus({ preventScroll: true });\n\n    target.classList.add(\"footnote-highlight\");\n    setTimeout(function () {\n      target.classList.remove(\"footnote-highlight\");\n      if (!hadTabindex) {\n        target.removeAttribute(\"tabindex\");\n      } else if (prevTabindex !== null) {\n        target.setAttribute(\"tabindex\", prevTabindex);\n      }\n    }, HIGHLIGHT_MS);\n  }\n\n  // --- Event wiring ---------------------------------------------------------\n  function isFootnoteHref(href) {\n    // handle #fn1, #fnref1, etc.\n    return /^#fn(ref)?/i.test(href || \"\");\n  }\n\n  function handleClick(e) {\n    var a = e.target.closest('a[href^=\"#\"]');\n    if (!a) return;\n    var href = a.getAttribute(\"href\");\n    if (!isFootnoteHref(href)) return;\n\n    var id = href.slice(1);\n    var target = document.getElementById(id);\n    if (!target) return;\n\n    e.preventDefault();\n    scrollToTarget(target);\n  }\n\n  function handleInitialHash() {\n    var hash = window.location.hash;\n    if (!isFootnoteHref(hash)) return;\n    var target = document.getElementById(hash.slice(1));\n    if (!target) return;\n\n    // Wait a tick for layout to settle (fonts, images)\n    setTimeout(function () {\n      scrollToTarget(target, { skipHistory: true });\n    }, 50);\n  }\n\n  function enhanceFootnoteNavigation() {\n    updateScrollMargin();\n    watchHeader();\n\n    window.addEventListener(\"resize\", onResize, { passive: true });\n    document.addEventListener(\"click\", handleClick, false);\n    window.addEventListener(\"popstate\", handleInitialHash, false);\n\n    if (document.readyState === \"loading\") {\n      document.addEventListener(\"DOMContentLoaded\", handleInitialHash, { once: true });\n    } else {\n      handleInitialHash();\n    }\n  }\n\n  // Opt-out: allow a page to disable smoothing globally\n  if (!document.documentElement.hasAttribute(\"data-no-smooth-scroll\")) {\n    enhanceFootnoteNavigation();\n  }\n})();\n",
  "src/assets/js/mschf-seed.mjs": "export function randomInt() { return crypto.getRandomValues(new Uint32Array(1))[0].toString(); }\nexport function mulberry32(seed) {\n  let t = seed >>> 0; return function () {\n    t += 0x6D2B79F5; let r = Math.imul(t ^ (t >>> 15), t | 1);\n    r ^= r + Math.imul(r ^ (r >>> 7), r | 61);\n    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;\n  };\n}\nexport function computeSeed(mode = \"page\", forced, storage) {\n  if (forced) return String(forced);\n  if (mode === \"session\" && storage) {\n    const existing = storage.getItem(\"mschfSeed\");\n    if (existing) return existing;\n    const next = randomInt(); storage.setItem(\"mschfSeed\", next); return next;\n  }\n  return randomInt();\n}",
  "src/assets/js/theme-toggle.js": "(function () {\n  \"use strict\";\n\n  var btn = document.getElementById(\"theme-toggle\");\n  if (!btn) return;\n\n  var utils = window.ThemeUtils || null;\n  var sun = btn.querySelector(\".lucide-sun\");\n  var moon = btn.querySelector(\".lucide-moon\");\n\n  function reflect(theme) {\n    var dark = (utils ? utils.THEMES.dark : \"dark\");\n    var isDark = theme === dark;\n    btn.setAttribute(\"aria-pressed\", String(isDark));\n    btn.setAttribute(\"aria-label\", isDark ? \"Switch to light theme\" : \"Switch to dark theme\");\n    if (sun && moon) {\n      sun.classList.toggle(\"hidden\", isDark);\n      moon.classList.toggle(\"hidden\", !isDark);\n    }\n  }\n\n  // Initial reflect from current document state\n  reflect((utils && utils.getTheme()) || document.documentElement.getAttribute(\"data-theme\") || \"light\");\n\n  if (utils) {\n    btn.addEventListener(\"click\", function () { reflect(utils.toggleTheme(true)); });\n    utils.onChange(reflect);\n  } else {\n    // Minimal fallback toggle if ThemeUtils is not present (shouldn't happen)\n    btn.addEventListener(\"click\", function () {\n      var el = document.documentElement;\n      var cur = el.getAttribute(\"data-theme\") || \"light\";\n      var next = cur === \"dark\" ? \"light\" : \"dark\";\n      el.setAttribute(\"data-theme\", next);\n      reflect(next);\n    });\n  }\n})();\n",
  "src/assets/js/code-copy.js": "document.addEventListener('DOMContentLoaded', () => {\n  document.querySelectorAll('pre > code').forEach(code => {\n    const pre = code.parentElement;\n    const btn = document.createElement('button');\n    btn.textContent = 'copy';\n    btn.dataset.copy = '';\n    btn.style.marginBottom = '0.5rem';\n    btn.addEventListener('click', () => {\n      navigator.clipboard.writeText(code.textContent).then(() => {\n        btn.textContent = 'copied';\n        setTimeout(() => { btn.textContent = 'copy'; }, 2000);\n      });\n    });\n    pre.insertBefore(btn, code);\n  });\n});\n",
  "src/assets/js/theme-utils.js": "// src/assets/js/theme-utils.js\n// Framework-agnostic theme helpers for DaisyUI v5 themes.\n// Exposes a tiny global `ThemeUtils` for non-module usage and works without bundlers.\n(function (global) {\n  \"use strict\";\n\n  var STORAGE_KEY = \"theme\";\n  var THEMES = { light: \"light\", dark: \"dark\" };\n  var DEFAULT = THEMES.light;\n  var DARK_NAME = THEMES.dark;\n  var ALLOWED = [THEMES.light, THEMES.dark];\n\n  function configure(opts) {\n    try {\n      if (!opts || typeof opts !== \"object\") return;\n      if (Array.isArray(opts.allowed) && opts.allowed.length) {\n        ALLOWED = opts.allowed.map(String);\n      }\n      if (opts.defaultTheme && typeof opts.defaultTheme === \"string\") {\n        DEFAULT = opts.defaultTheme;\n      }\n      if (opts.darkTheme && typeof opts.darkTheme === \"string\") {\n        DARK_NAME = opts.darkTheme;\n      }\n      if (opts.storageKey && typeof opts.storageKey === \"string\") {\n        STORAGE_KEY = opts.storageKey;\n      }\n    } catch (_) { /* noop */ }\n  }\n\n  function getTheme() {\n    var el = document.documentElement;\n    var t = el.getAttribute(\"data-theme\");\n    if (!t || ALLOWED.indexOf(t) === -1) {\n      // Fallback to storage then default\n      try {\n        var s = localStorage.getItem(STORAGE_KEY);\n        if (s && ALLOWED.indexOf(s) !== -1) t = s;\n      } catch (_) {}\n    }\n    return ALLOWED.indexOf(t) !== -1 ? t : DEFAULT;\n  }\n\n  function setTheme(name, persist, source) {\n    if (ALLOWED.indexOf(name) === -1) return;\n    var el = document.documentElement;\n    el.setAttribute(\"data-theme\", name);\n    el.dataset.themeSource = source || \"user\";\n    var meta = document.querySelector('meta[name=\"color-scheme\"]');\n    if (meta) meta.setAttribute(\"content\", name === DEFAULT ? \"light dark\" : \"dark light\");\n    if (persist) {\n      try { localStorage.setItem(STORAGE_KEY, name); } catch (_) {}\n    }\n    try { document.dispatchEvent(new CustomEvent(\"themechange\", { detail: { theme: name, source: source || \"user\" } })); } catch (_) {}\n  }\n\n  function toggleTheme(persist) {\n    var cur = getTheme();\n    // Prefer binary toggle between DEFAULT and DARK_NAME\n    var next = cur === DARK_NAME ? DEFAULT : DARK_NAME;\n    setTheme(next, persist !== false, \"toggle\");\n    return next;\n  }\n\n  function initEarly() {\n    // Run as early as possible in <head> to avoid FART.\n    try {\n      var stored = localStorage.getItem(STORAGE_KEY);\n      var picked = (stored && ALLOWED.indexOf(stored) !== -1)\n        ? stored\n        : (window.matchMedia && window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? DARK_NAME : DEFAULT);\n      document.documentElement.setAttribute(\"data-theme\", picked);\n      document.documentElement.dataset.themeSource = stored ? \"storage\" : \"default\";\n      var meta = document.querySelector('meta[name=\"color-scheme\"]') || (function (){ var m=document.createElement(\"meta\"); m.name = \"color-scheme\"; document.head.appendChild(m); return m; })();\n      meta.content = (picked === DEFAULT) ? \"light dark\" : \"dark light\";\n    } catch (_) {\n      document.documentElement.setAttribute(\"data-theme\", DEFAULT);\n      document.documentElement.dataset.themeSource = \"fallback\";\n    }\n  }\n\n  function onChange(handler) {\n    if (typeof handler !== \"function\") return function () {};\n    var fn = function (e) { handler(e?.detail?.theme || getTheme(), e?.detail?.source || \"event\"); };\n    document.addEventListener(\"themechange\", fn);\n    return function unsubscribe() { document.removeEventListener(\"themechange\", fn); };\n  }\n\n  var api = { configure: configure, getTheme: getTheme, setTheme: setTheme, toggleTheme: toggleTheme, initEarly: initEarly, onChange: onChange, THEMES: THEMES };\n  global.ThemeUtils = api;\n})(window);\n",
  "src/assets/js/work-filters.js": "document.addEventListener('DOMContentLoaded', () => {\n  const buttons = document.querySelectorAll('[data-filter]');\n  const items = document.querySelectorAll('#work-list > li');\n  buttons.forEach(btn => {\n    btn.addEventListener('click', () => {\n      buttons.forEach(b => b.setAttribute('aria-pressed', b === btn ? 'true' : 'false'));\n      const filter = btn.dataset.filter;\n      items.forEach(li => {\n        const type = li.dataset.type;\n        li.classList.toggle('hidden', filter !== 'all' && type !== filter);\n      });\n    });\n  });\n});\n"
}
