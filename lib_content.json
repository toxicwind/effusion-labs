[
  {
    "path": "src/assets/css/hyperbrut.css",
    "content": "/* src/assets/css/hyperbrut.css */\n\n/* Base reset additions */\n@layer base {\n  *,::before,::after { box-sizing: border-box; }\n  html,body { height:100%; }\n  body { margin:0; line-height:1.5; -webkit-font-smoothing: antialiased; }\n  code { @apply font-mono text-sm px-1 rounded bg-base-300; }\n}\n\n/* Utility animations and z-index helpers */\n@layer utilities {\n  @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }\n  .animate-fade-in { animation: fade-in .3s ease-in-out both; }\n  .z-nav { z-index: 40; }\n  .z-modal { z-index: 50; }\n\n  .stack { @apply flex flex-col gap-4; }\n  .center { @apply mx-auto max-w-screen-lg; }\n  .hb-fluid-h1 { @apply text-4xl sm:text-5xl md:text-7xl lg:text-8xl; }\n  .hb-fluid-h2 { @apply text-3xl sm:text-4xl md:text-6xl lg:text-7xl; }\n  .hb-fluid-kicker { @apply text-lg sm:text-xl md:text-2xl; }\n  .hb-bleed-reset { @apply mr-0 max-w-full; }\n}\n\n/* Hyperbrut visual language */\n@layer utilities {\n  .hb-neon { --hb-g1: var(--spec-a,#00E0FF); --hb-g2: var(--spec-c,#FF1CF7);\n    background-image: linear-gradient(120deg,\n      color-mix(in oklab, var(--hb-g1), transparent 10%),\n      color-mix(in oklab, var(--hb-g2), transparent 10%)); }\n\n  .hb-intensity-lite { --hb-shadow-a:.28; --hb-rail-a:.45; }\n  .hb-intensity-bold { --hb-shadow-a:.52; --hb-rail-a:.8; }\n\n  .hb-accent { position: relative; }\n  .hb-accent::before { content:\"\"; position:absolute; inset:0 auto 0 -1px; width:var(--spec-rail-w,3px);\n    background:var(--spectrum); opacity:var(--spec-alpha,.35); pointer-events:none; }\n\n  .hb-inlay { background: color-mix(in oklab, hsl(var(--b1)) 80%, hsl(var(--b2)) 20%);\n    border-radius:.8rem; box-shadow: 0 0 0 2px color-mix(in oklab, hsl(var(--b3)) 70%, transparent),\n    0 10px 24px rgba(0,0,0,.20); backdrop-filter: saturate(120%) blur(6px); }\n\n  .hb-ink { color: hsl(var(--bc)); }\n  .hb-ink-soft { color: color-mix(in oklab, hsl(var(--bc)) 80%, transparent); }\n\n  .hb-shadow-brut { box-shadow: 6px 6px 0 rgba(0,0,0,calc(var(--hb-shadow-a,.32))), 0 0 0 2px rgba(0,0,0,.85); }\n  .hb-shadow-brut:hover { box-shadow: 8px 8px 0 rgba(0,0,0,calc(var(--hb-shadow-a,.32))), 0 0 0 2px rgba(0,0,0,.9); transform: translate(-1px,-1px); }\n\n  .hb-brut-card { border-radius:.75rem; border:2px solid hsl(var(--b3));\n    background: linear-gradient(135deg, hsl(var(--b2)) 0%, hsl(var(--b1)) 100%);\n    box-shadow: 0 1px 0 rgba(255,255,255,.04) inset, 0 14px 28px rgba(0,0,0,.20);\n    transition: transform .18s ease, box-shadow .18s ease, filter .18s ease; }\n  .hb-brut-card:hover { transform: translateY(-2px);\n    box-shadow: 0 1px 0 rgba(255,255,255,.04) inset, 0 18px 34px rgba(0,0,0,.24); }\n\n  .hb-plasma { text-shadow: 0 1px 0 rgba(0,0,0,.35);\n    box-shadow: 0 0 0 2px rgba(0,0,0,.8), 0 10px 22px color-mix(in oklab, hsl(var(--p)) 35%, transparent); }\n  .hb-plasma:hover { box-shadow: 0 0 0 2px rgba(0,0,0,.85), 0 14px 28px color-mix(in oklab, hsl(var(--p)) 45%, transparent); }\n\n  .hb-grid { background-image:\n      radial-gradient(circle at 2px 2px, rgba(0,255,65,.18) 1.2px, transparent 0),\n      linear-gradient(to right, rgba(255,255,255,.05) 1px, transparent 1px),\n      linear-gradient(to bottom, rgba(255,255,255,.05) 1px, transparent 1px);\n    background-size: 40px 40px, 20px 20px, 20px 20px; }\n\n  .hb-underline { position:relative; display:inline-block; padding-bottom:.35rem; }\n  .hb-underline::after { content:\"\"; position:absolute; left:0; bottom:0; height:var(--spec-underline-w,2px);\n    width: clamp(5rem, 10vw, 10rem); background: var(--spectrum-x); opacity:.9; }\n\n  .hb-field { box-shadow: 3px 3px 0 rgba(0,0,0,.55); border-width: 2px !important; }\n  .hb-field:focus { box-shadow: 4px 4px 0 rgba(0,0,0,.6); }\n\n  .hb-accent-top { position:relative; }\n  .hb-accent-top::before { content:\"\"; position:absolute; inset:-1px 0 auto 0; height:var(--spec-rail-w,3px);\n    background: var(--spectrum-x); opacity: var(--spec-alpha,.35); pointer-events:none; }\n\n  .hb-stat-card { position:relative; overflow:hidden; }\n  .hb-num-outline {\n    text-shadow: 1px 1px 0 rgba(0,0,0,.65), -1px -1px 0 rgba(0,0,0,.35),\n                 1px -1px 0 rgba(0,0,0,.45), -1px 1px 0 rgba(0,0,0,.45);\n    letter-spacing:-.02em;\n  }\n  .hb-scanbar { height:4px; background: var(--spectrum-x); border-radius:2px; opacity:.9; }\n\n  .hb-anim { transition: transform .18s ease, box-shadow .18s ease; }\n  .hb-overflow-visible { overflow: visible !important; }\n\n  .hb-logo { width:2.5rem; height:2.5rem; padding:2px; border-radius:9999px; display:inline-flex; align-items:center; justify-content:center; background: conic-gradient(from 120deg, var(--spec-a), var(--spec-c), var(--spec-d)); box-shadow: 4px 4px 0 rgba(0,0,0,.7); }\n  .hb-logo-core { width:100%; height:100%; border-radius:9999px; display:inline-flex; align-items:center; justify-content:center; background:hsl(var(--p)); color:#000; font-weight:800; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; }\n\n  .hb-blobs { position:relative; }\n  .hb-blobs::before, .hb-blobs::after { content:\"\"; position:fixed; inset:auto auto 10% -10%; width:40vmax; height:40vmax; border-radius:50%; filter:blur(60px); opacity:.12; pointer-events:none; z-index:0; }\n  .hb-blobs::before { inset:5% -10% auto auto; background: radial-gradient(circle at 30% 30%, color-mix(in oklab, hsl(var(--p)) 60%, transparent), transparent 60%); }\n  .hb-blobs::after  { inset:auto auto -10% 50%; background: radial-gradient(circle at 60% 40%, color-mix(in oklab, hsl(var(--a)) 60%, transparent), transparent 60%); }\n  .hb-vignette::after { content:\"\"; position:fixed; inset:0; box-shadow: inset 0 0 120px rgba(0,0,0,.35); pointer-events:none; z-index:0; }\n  .hb-noise::after { content:\"\"; position:fixed; inset:0; background-image: repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0 1px, transparent 1px 2px),\n                                                repeating-linear-gradient(90deg, rgba(255,255,255,.02) 0 1px, transparent 1px 2px);\n    mix-blend-mode: overlay; pointer-events:none; z-index:0; }\n}\n\n/* Component polish (brut border radii, inputs, navbar underline, etc.) */\n@layer components {\n  .btn, .badge, .card, .alert, .menu, .kbd, .tab, .input, .select, .textarea { border-radius: var(--radius); border-width: 2px; }\n  .title-glow { text-shadow: 0 0 .025em #fff, 0 0 .2em var(--fallback-p, theme(colors.primary)); }\n\n  .chip-elevated { border-width: 2px; box-shadow: 4px 4px 0 rgba(0,0,0,.9); }\n\n  .input, .select, .textarea { @apply focus:outline-none focus:ring-2 focus:ring-primary; }\n  .modal { @apply backdrop-blur; }\n  .alert { @apply text-base-content; }\n  .badge { @apply rounded-md; }\n  .btn { @apply font-semibold; }\n  .card { @apply shadow-sm; }\n  .breadcrumb { @apply text-sm; }\n  .pagination { @apply flex items-center gap-2; }\n\n  .navbar .link-underline { position: relative; }\n  .navbar .link-underline::after {\n    content: \"\"; position: absolute; left: 0; bottom: -.25rem; height: 2px; width: 0; background-color: currentColor; transition: width 200ms ease;\n  }\n  .navbar .link-underline:hover::after,\n  .navbar .link-underline:focus-visible::after { width: 100%; }\n}\n@media (prefers-reduced-motion: reduce) {\n  .navbar .link-underline::after { transition: none; }\n}\n"
  },
  {
    "path": "src/assets/css/app.css",
    "content": "/* src/assets/css/app.css\n   Tailwind v4 + daisyUI v5 via Vite (CSS-first)\n   Single entry: includes tokens + Hyperbrut layers. */\n\n@import \"tailwindcss\";\n@plugin \"@tailwindcss/typography\";\n@plugin \"daisyui\";\n\n/* -------------------- */\n/* Site tokens in CSS   */\n/* -------------------- */\n\n/* Light/Dark color tokens */\n:root,\nhtml[data-theme=\"light\"] {\n  --color-bg: 245 245 245;\n  --color-surface: 230 230 230;\n  --color-text: 30 30 30;\n  --color-primary: 10 132 255;\n  --color-border: 200 200 200;\n  --color-code-bg: 235 235 235;\n  --color-code-text: 30 30 30;\n}\nhtml[data-theme=\"dark\"] {\n  --color-bg: 18 18 18;\n  --color-surface: 35 35 35;\n  --color-text: 235 235 235;\n  --color-primary: 10 132 255;\n  --color-border: 60 60 60;\n  --color-code-bg: 40 40 40;\n  --color-code-text: 235 235 235;\n}\n\n/* Spectrum + layout tokens */\n:root {\n  --page-w: min(110rem, 92vw);\n  --spec-a: #00E0FF; --spec-b: #9AFF00; --spec-c: #FF1CF7; --spec-d: #FFC700;\n  --spectrum: linear-gradient(180deg, var(--spec-a), var(--spec-b) 33%, var(--spec-c) 66%, var(--spec-d));\n  --spectrum-x: linear-gradient(90deg, var(--spec-a), var(--spec-c));\n  --spec-alpha: .35; --spec-rail-w: 3px; --spec-underline-w: 2px; --spec-chip-bw: 2px;\n\n  /* Small global niceties */\n  --radius: .5rem;\n}\n@media (min-width:1920px){ :root{ --page-w: min(130rem, 88vw); } }\n@media (min-width:2560px){ :root{ --page-w: min(150rem, 84vw); } }\n@media (min-width:3840px){ :root{ --page-w: min(168rem, 78vw); } }\n\n/* Smooth scrolling */\nhtml { scroll-behavior: smooth; }\n\n/* -------------------- */\n/* Base layer           */\n/* -------------------- */\n@layer base {\n  *,::before,::after { box-sizing: border-box; }\n  html,body { height:100%; }\n  body { margin:0; line-height:1.5; -webkit-font-smoothing: antialiased; }\n\n  code { @apply font-mono text-sm px-1 rounded bg-base-300; }\n}\n\n/* -------------------- */\n/* Utilities            */\n/* -------------------- */\n@layer utilities {\n  @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }\n  .animate-fade-in { animation: fade-in .3s ease-in-out both; }\n\n  .z-nav { z-index: 40; }\n  .z-modal { z-index: 50; }\n\n  .stack { @apply flex flex-col gap-4; }\n  .center { @apply mx-auto max-w-screen-lg; }\n  .hb-fluid-h1 { @apply text-4xl sm:text-5xl md:text-7xl lg:text-8xl; }\n  .hb-fluid-h2 { @apply text-3xl sm:text-4xl md:text-6xl lg:text-7xl; }\n  .hb-fluid-kicker { @apply text-lg sm:text-xl md:text-2xl; }\n  .hb-bleed-reset { @apply mr-0 max-w-full; }\n\n  /* Hyperbrut visuals */\n  .hb-neon {\n    --hb-g1: var(--spec-a, #00E0FF);\n    --hb-g2: var(--spec-c, #FF1CF7);\n    background-image: linear-gradient(120deg,\n      color-mix(in oklab, var(--hb-g1), transparent 10%),\n      color-mix(in oklab, var(--hb-g2), transparent 10%));\n  }\n\n  .hb-intensity-lite { --hb-shadow-a:.28; --hb-rail-a:.45; }\n  .hb-intensity-bold { --hb-shadow-a:.52; --hb-rail-a:.8; }\n\n  .hb-accent { position: relative; }\n  .hb-accent::before {\n    content:\"\"; position:absolute; inset:0 auto 0 -1px; width:var(--spec-rail-w,3px);\n    background:var(--spectrum); opacity:var(--spec-alpha,.35); pointer-events:none;\n  }\n\n  .hb-inlay {\n    background: color-mix(in oklab, hsl(var(--b1)) 80%, hsl(var(--b2)) 20%);\n    border-radius:.8rem;\n    box-shadow: 0 0 0 2px color-mix(in oklab, hsl(var(--b3)) 70%, transparent),\n                0 10px 24px rgba(0,0,0,.20);\n    backdrop-filter: saturate(120%) blur(6px);\n  }\n\n  .hb-ink { color: hsl(var(--bc)); }\n  .hb-ink-soft { color: color-mix(in oklab, hsl(var(--bc)) 80%, transparent); }\n\n  .hb-shadow-brut {\n    box-shadow: 6px 6px 0 rgba(0,0,0,calc(var(--hb-shadow-a,.32))),\n                0 0 0 2px rgba(0,0,0,.85);\n  }\n  .hb-shadow-brut:hover {\n    box-shadow: 8px 8px 0 rgba(0,0,0,calc(var(--hb-shadow-a,.32))),\n                0 0 0 2px rgba(0,0,0,.9);\n    transform: translate(-1px,-1px);\n  }\n\n  .hb-brut-card {\n    border-radius:.75rem;\n    border:2px solid hsl(var(--b3));\n    background: linear-gradient(135deg, hsl(var(--b2)) 0%, hsl(var(--b1)) 100%);\n    box-shadow: 0 1px 0 rgba(255,255,255,.04) inset,\n                0 14px 28px rgba(0,0,0,.20);\n    transition: transform .18s ease, box-shadow .18s ease, filter .18s ease;\n  }\n  .hb-brut-card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 1px 0 rgba(255,255,255,.04) inset,\n                0 18px 34px rgba(0,0,0,.24);\n  }\n\n  .hb-plasma {\n    text-shadow: 0 1px 0 rgba(0,0,0,.35);\n    box-shadow: 0 0 0 2px rgba(0,0,0,.8),\n                0 10px 22px color-mix(in oklab, hsl(var(--p)) 35%, transparent);\n  }\n  .hb-plasma:hover {\n    box-shadow: 0 0 0 2px rgba(0,0,0,.85),\n                0 14px 28px color-mix(in oklab, hsl(var(--p)) 45%, transparent);\n  }\n\n  .hb-grid {\n    background-image:\n      radial-gradient(circle at 2px 2px, rgba(0,255,65,.18) 1.2px, transparent 0),\n      linear-gradient(to right, rgba(255,255,255,.05) 1px, transparent 1px),\n      linear-gradient(to bottom, rgba(255,255,255,.05) 1px, transparent 1px);\n    background-size: 40px 40px, 20px 20px, 20px 20px;\n  }\n\n  .hb-underline { position:relative; display:inline-block; padding-bottom:.35rem; }\n  .hb-underline::after {\n    content:\"\"; position:absolute; left:0; bottom:0; height:var(--spec-underline-w,2px);\n    width: clamp(5rem, 10vw, 10rem);\n    background: var(--spectrum-x);\n    opacity:.9;\n  }\n\n  .hb-field { box-shadow: 3px 3px 0 rgba(0,0,0,.55); border-width: 2px !important; }\n  .hb-field:focus { box-shadow: 4px 4px 0 rgba(0,0,0,.6); }\n\n  .hb-accent-top { position:relative; }\n  .hb-accent-top::before {\n    content:\"\"; position:absolute; inset:-1px 0 auto 0; height:var(--spec-rail-w,3px);\n    background: var(--spectrum-x); opacity: var(--spec-alpha,.35); pointer-events:none;\n  }\n\n  .hb-stat-card { position:relative; overflow:hidden; }\n  .hb-num-outline {\n    text-shadow: 1px 1px 0 rgba(0,0,0,.65), -1px -1px 0 rgba(0,0,0,.35),\n                 1px -1px 0 rgba(0,0,0,.45), -1px 1px 0 rgba(0,0,0,.45);\n    letter-spacing:-.02em;\n  }\n  .hb-scanbar { height:4px; background: var(--spectrum-x); border-radius:2px; opacity:.9; }\n\n  .hb-anim { transition: transform .18s ease, box-shadow .18s ease; }\n  .hb-overflow-visible { overflow: visible !important; }\n\n  .hb-logo {\n    width:2.5rem; height:2.5rem; padding:2px; border-radius:9999px;\n    display:inline-flex; align-items:center; justify-content:center;\n    background: conic-gradient(from 120deg, var(--spec-a), var(--spec-c), var(--spec-d));\n    box-shadow: 4px 4px 0 rgba(0,0,0,.7);\n  }\n  .hb-logo-core {\n    width:100%; height:100%; border-radius:9999px;\n    display:inline-flex; align-items:center; justify-content:center;\n    background:hsl(var(--p)); color:#000; font-weight:800;\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;\n  }\n\n  .hb-blobs { position:relative; }\n  .hb-blobs::before, .hb-blobs::after {\n    content:\"\"; position:fixed; inset:auto auto 10% -10%;\n    width:40vmax; height:40vmax; border-radius:50%;\n    filter:blur(60px); opacity:.12; pointer-events:none; z-index:0;\n  }\n  .hb-blobs::before {\n    inset:5% -10% auto auto;\n    background: radial-gradient(circle at 30% 30%, color-mix(in oklab, hsl(var(--p)) 60%, transparent), transparent 60%);\n  }\n  .hb-blobs::after  {\n    inset:auto auto -10% 50%;\n    background: radial-gradient(circle at 60% 40%, color-mix(in oklab, hsl(var(--a)) 60%, transparent), transparent 60%);\n  }\n  .hb-vignette::after {\n    content:\"\"; position:fixed; inset:0; box-shadow: inset 0 0 120px rgba(0,0,0,.35);\n    pointer-events:none; z-index:0;\n  }\n  .hb-noise::after {\n    content:\"\"; position:fixed; inset:0;\n    background-image:\n      repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0 1px, transparent 1px 2px),\n      repeating-linear-gradient(90deg, rgba(255,255,255,.02) 0 1px, transparent 1px 2px);\n    mix-blend-mode: overlay; pointer-events:none; z-index:0;\n  }\n}\n\n/* -------------------- */\n/* Components           */\n/* -------------------- */\n@layer components {\n  .btn, .badge, .card, .alert, .menu, .kbd, .tab, .input, .select, .textarea {\n    border-radius: var(--radius);\n    border-width: 2px;\n  }\n\n  .title-glow { text-shadow: 0 0 .025em #fff, 0 0 .2em var(--fallback-p, theme(colors.primary)); }\n  .chip-elevated { border-width: 2px; box-shadow: 4px 4px 0 rgba(0,0,0,.9); }\n\n  .input, .select, .textarea { @apply focus:outline-none focus:ring-2 focus:ring-primary; }\n  .modal { @apply backdrop-blur; }\n  .alert { @apply text-base-content; }\n  .badge { @apply rounded-md; }\n  .btn { @apply font-semibold; }\n  .card { @apply shadow-sm; }\n  .breadcrumb { @apply text-sm; }\n  .pagination { @apply flex items-center gap-2; }\n\n  .navbar .link-underline { position: relative; }\n  .navbar .link-underline::after {\n    content: \"\"; position: absolute; left: 0; bottom: -.25rem; height: 2px; width: 0;\n    background-color: currentColor; transition: width 200ms ease;\n  }\n  .navbar .link-underline:hover::after,\n  .navbar .link-underline:focus-visible::after { width: 100%; }\n}\n@media (prefers-reduced-motion: reduce) {\n  .navbar .link-underline::after { transition: none; }\n}\n"
  },
  {
    "path": "src/assets/css/overlay.css",
    "content": "/* src/assets/css/overlay.css */\n/* Site-specific micro tweaks that you want after everything else */\n\n@layer utilities {\n  .no-underline-on-hover:hover { text-decoration: none !important; }\n}\n\n@layer components {\n  .hb-toaster { @apply toast toast-end z-50; }\n}\n"
  },
  {
    "path": "src/assets/css/.gitkeep",
    "content": ""
  },
  {
    "path": "src/assets/css/tokens.css",
    "content": "/* src/assets/css/tokens.css */\n:root {\n  --step--2: clamp(0.79rem, calc(0.75rem + 0.17vw), 0.94rem);\n  --step--1: clamp(0.89rem, calc(0.84rem + 0.17vw), 1.06rem);\n  --step-0: clamp(1rem, calc(0.94rem + 0.17vw), 1.2rem);\n  --step-1: clamp(1.13rem, calc(1.06rem + 0.27vw), 1.44rem);\n  --step-2: clamp(1.27rem, calc(1.19rem + 0.35vw), 1.73rem);\n  --step-3: clamp(1.42rem, calc(1.33rem + 0.43vw), 2.07rem);\n  --step-4: clamp(1.6rem, calc(1.48rem + 0.52vw), 2.49rem);\n}\n\n/* Light/Dark color tokens */\n:root,\nhtml[data-theme=\"light\"] {\n  --color-bg: 245 245 245;\n  --color-surface: 230 230 230;\n  --color-text: 30 30 30;\n  --color-primary: 10 132 255;\n  --color-border: 200 200 200;\n  --color-code-bg: 235 235 235;\n  --color-code-text: 30 30 30;\n}\nhtml[data-theme=\"dark\"] {\n  --color-bg: 18 18 18;\n  --color-surface: 35 35 35;\n  --color-text: 235 235 235;\n  --color-primary: 10 132 255;\n  --color-border: 60 60 60;\n  --color-code-bg: 40 40 40;\n  --color-code-text: 235 235 235;\n}\n\n/* Spectrum + layout tokens */\n:root {\n  --page-w: min(110rem, 92vw);\n  --spec-a:#00E0FF; --spec-b:#9AFF00; --spec-c:#FF1CF7; --spec-d:#FFC700;\n  --spectrum: linear-gradient(180deg,var(--spec-a),var(--spec-b) 33%,var(--spec-c) 66%,var(--spec-d));\n  --spectrum-x: linear-gradient(90deg,var(--spec-a),var(--spec-c));\n  --spec-alpha:.35; --spec-rail-w:3px; --spec-underline-w:2px; --spec-chip-bw:2px;\n}\n@media (min-width:1920px){ :root{ --page-w: min(130rem, 88vw); } }\n@media (min-width:2560px){ :root{ --page-w: min(150rem, 84vw); } }\n@media (min-width:3840px){ :root{ --page-w: min(168rem, 78vw); } }\n"
  },
  {
    "path": "src/assets/js/app.js",
    "content": "// src/assets/js/app.js\n// Vite entry: imports CSS and initializes all page-level JS.\n// Consolidates: footnote nav, theme toggle, code copy, work filters.\n// Lazily loads the heavy overlay only when conditions are good.\n\nimport \"/assets/css/app.css\";\n\n/* -------------------------------\n   tiny utils\n--------------------------------*/\nconst onReady = (cb) => {\n    if (document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", cb, { once: true });\n    } else {\n        cb();\n    }\n};\nconst qs = (sel, root = document) => root.querySelector(sel);\nconst qsa = (sel, root = document) => Array.from(root.querySelectorAll(sel));\nconst prefersReducedMotion = () =>\n    window.matchMedia?.(\"(prefers-reduced-motion: reduce)\")?.matches ?? false;\nconst saveData = () => {\n    try {\n        const c = navigator.connection;\n        return !!(c && (c.saveData || /2g/.test(c.effectiveType || \"\")));\n    } catch {\n        return false;\n    }\n};\n\n/* -------------------------------\n   1) Footnote navigation\n   (sticky header aware + highlight)\n--------------------------------*/\nfunction initFootnotes() {\n    const EXTRA = 16;\n\n    const getHeaderEl = () =>\n        qs(\"[data-site-header]\") ||\n        qs('[role=\"banner\"]') ||\n        qs(\"header.site-header\") ||\n        qs(\"body > header\") ||\n        qs(\"header\");\n\n    const readCssVar = () =>\n        parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--header-height\")) || null;\n\n    const calcHeaderHeight = () => {\n        const fromVar = readCssVar();\n        if (Number.isFinite(fromVar)) return Math.ceil(fromVar);\n        const h = getHeaderEl();\n        if (!h) return 80 + EXTRA;\n        const r = h.getBoundingClientRect();\n        return Math.ceil(r.height) + EXTRA;\n    };\n\n    const setVar = (px) =>\n        document.documentElement.style.setProperty(\"--header-height\", `${px}px`);\n\n    const updateHeaderVar = () => setVar(calcHeaderHeight());\n\n    // keep var fresh\n    let resizeRaf = 0;\n    const onResize = () => {\n        if (resizeRaf) return;\n        resizeRaf = requestAnimationFrame(() => {\n            resizeRaf = 0;\n            updateHeaderVar();\n        });\n    };\n    const h = getHeaderEl();\n    if (\"ResizeObserver\" in window && h) {\n        new ResizeObserver(updateHeaderVar).observe(h);\n    }\n    window.addEventListener(\"resize\", onResize, { passive: true });\n    updateHeaderVar();\n\n    const isFnHash = (href = \"\") => /^#fn(ref)?/i.test(href);\n\n    const applyHighlight = (el) => {\n        if (!el) return;\n        const hadTabindex = el.hasAttribute(\"tabindex\");\n        const prev = el.getAttribute(\"tabindex\");\n        if (!hadTabindex) el.setAttribute(\"tabindex\", \"-1\");\n        el.classList.add(\"footnote-highlight\");\n        el.focus({ preventScroll: true });\n        setTimeout(() => {\n            el.classList.remove(\"footnote-highlight\");\n            if (!hadTabindex) el.removeAttribute(\"tabindex\");\n            else if (prev !== null) el.setAttribute(\"tabindex\", prev);\n        }, 2200);\n    };\n\n    const smoothScrollTo = (target, { skipHistory } = {}) => {\n        if (!target) return;\n        const header = calcHeaderHeight();\n        const rect = target.getBoundingClientRect();\n        const top = Math.max(0, window.pageYOffset + rect.top - header);\n        window.scrollTo({ top, behavior: prefersReducedMotion() ? \"auto\" : \"smooth\" });\n        if (!skipHistory) {\n            const id = target.id ? `#${target.id}` : \"\";\n            if (id && id !== location.hash) {\n                try {\n                    history.pushState(null, \"\", id);\n                } catch { }\n            }\n        }\n        applyHighlight(target);\n    };\n\n    document.addEventListener(\n        \"click\",\n        (e) => {\n            const a = e.target.closest('a[href^=\"#\"]');\n            if (!a) return;\n            const href = a.getAttribute(\"href\");\n            if (!isFnHash(href)) return;\n            const target = qs(href);\n            if (!target) return;\n            e.preventDefault();\n            smoothScrollTo(target);\n        },\n        false\n    );\n\n    const handleInitial = () => {\n        const { hash } = window.location;\n        if (!isFnHash(hash)) return;\n        const t = qs(hash);\n        if (!t) return;\n        setTimeout(() => smoothScrollTo(t, { skipHistory: true }), 50);\n    };\n\n    window.addEventListener(\"popstate\", handleInitial, false);\n    handleInitial();\n}\n\n/* -------------------------------\n   2) Theme toggle button\n   (uses global ThemeUtils from head)\n--------------------------------*/\nfunction initThemeToggle() {\n    const btn = qs(\"#theme-toggle\");\n    if (!btn) return;\n\n    const utils = window.ThemeUtils || null;\n    const sun = btn.querySelector(\".lucide-sun\");\n    const moon = btn.querySelector(\".lucide-moon\");\n\n    const reflect = (theme) => {\n        const dark = utils ? utils.THEMES.dark : \"dark\";\n        const isDark = theme === dark;\n        btn.setAttribute(\"aria-pressed\", String(isDark));\n        btn.setAttribute(\"aria-label\", isDark ? \"Switch to light theme\" : \"Switch to dark theme\");\n        if (sun && moon) {\n            sun.classList.toggle(\"hidden\", isDark);\n            moon.classList.toggle(\"hidden\", !isDark);\n        }\n    };\n\n    reflect(\n        (utils && utils.getTheme()) ||\n        document.documentElement.getAttribute(\"data-theme\") ||\n        \"light\"\n    );\n\n    if (utils) {\n        btn.addEventListener(\"click\", () => reflect(utils.toggleTheme(true)));\n        utils.onChange(reflect);\n    } else {\n        // Fallback (shouldn’t happen)\n        btn.addEventListener(\"click\", () => {\n            const el = document.documentElement;\n            const cur = el.getAttribute(\"data-theme\") || \"light\";\n            const next = cur === \"dark\" ? \"light\" : \"dark\";\n            el.setAttribute(\"data-theme\", next);\n            reflect(next);\n        });\n    }\n}\n\n/* -------------------------------\n   3) Code copy buttons\n--------------------------------*/\nfunction initCodeCopy() {\n    const blocks = qsa(\"pre > code\");\n    if (!blocks.length) return;\n    for (const code of blocks) {\n        const pre = code.parentElement;\n        if (!pre || pre.querySelector(\"button[data-copy]\")) continue;\n        const btn = document.createElement(\"button\");\n        btn.type = \"button\";\n        btn.dataset.copy = \"\";\n        btn.className = \"btn btn-xs btn-ghost hb-anim\";\n        btn.textContent = \"copy\";\n        btn.style.marginBottom = \"0.5rem\";\n        btn.addEventListener(\"click\", async () => {\n            try {\n                await navigator.clipboard.writeText(code.textContent || \"\");\n                const prev = btn.textContent;\n                btn.textContent = \"copied\";\n                setTimeout(() => (btn.textContent = prev), 1500);\n            } catch { }\n        });\n        pre.insertBefore(btn, code);\n    }\n}\n\n/* -------------------------------\n   4) Work filters\n--------------------------------*/\nfunction initWorkFilters() {\n    const buttons = qsa(\"[data-filter]\");\n    const items = qsa(\"#work-list > li\");\n    if (!buttons.length || !items.length) return;\n\n    const apply = (filter) => {\n        for (const li of items) {\n            const type = li.dataset.type;\n            li.classList.toggle(\"hidden\", filter !== \"all\" && type !== filter);\n        }\n    };\n\n    for (const btn of buttons) {\n        btn.addEventListener(\"click\", () => {\n            for (const b of buttons) {\n                b.setAttribute(\"aria-pressed\", b === btn ? \"true\" : \"false\");\n            }\n            apply(btn.dataset.filter || \"all\");\n        });\n    }\n}\n\n/* -------------------------------\n   5) Lazy overlay loader\n   (only when it won’t hurt UX)\n--------------------------------*/\nfunction initOverlayLoader() {\n    const body = document.body || document.documentElement;\n    const overlayOff = body?.dataset?.mschf === \"off\" || localStorage.getItem(\"mschf:off\") === \"1\";\n    const forceOn = new URLSearchParams(location.search).get(\"overlay\") === \"1\" || body?.dataset?.overlay === \"1\";\n    const isLg = window.matchMedia?.(\"(min-width: 1024px)\")?.matches ?? false;\n\n    // Conditions: not disabled, large screens, no save-data, no reduced motion\n    const shouldLoad =\n        !overlayOff && (forceOn || (isLg && !saveData() && !prefersReducedMotion()));\n\n    if (!shouldLoad) return;\n\n    const doImport = () => import(\"./mschf-overlay.js\").catch(() => { });\n    if (\"requestIdleCallback\" in window) {\n        // Give main content time to settle\n        requestIdleCallback(() => doImport(), { timeout: 2000 });\n    } else {\n        setTimeout(doImport, 600);\n    }\n}\n\n/* -------------------------------\n   bootstrap\n--------------------------------*/\nonReady(() => {\n    initFootnotes();\n    initThemeToggle();\n    initCodeCopy();\n    initWorkFilters();\n    initOverlayLoader();\n});\n"
  },
  {
    "path": "src/assets/js/mschf-overlay.js",
    "content": "// Effusion Labs — Hypebrüt Overlay v2.1 (Garden-Calm)\n// Non-blocking, prose-safe, SPA-safe, mobile-sane, reduced-motion/data aware.\n// Console: __mschfOn(), __mschfOff(), __mschfPulse(), __mschfMood(m), __mschfDensity(x), __mschfMask(0|1), __mschfAlpha(x)\n\n(() => {\n  if (window.__mschfBooted) {\n    try { console.warn('[MSCHF] Boot skipped — already booted.'); } catch {}\n    return;\n  }\n  window.__mschfBooted = true;\n\n  // ————————————————————————————————————————\n  // Debug toggles & helpers\n  // Enable with: body[data-mschf-debug=\"1\"], localStorage.setItem('mschf:debug','1'),\n  // window.__MSCHF_DEBUG = true, or URL ?mschfDebug=1\n  // ————————————————————————————————————————\n  const q = typeof location !== 'undefined' ? location.search : '';\n  const scope0 = (typeof document !== 'undefined' ? (document.body || document.documentElement) : null);\n  const DEBUG = !!(\n    (scope0 && scope0.dataset && scope0.dataset.mschfDebug === '1') ||\n    (typeof localStorage !== 'undefined' && localStorage.getItem('mschf:debug') === '1') ||\n    (typeof window !== 'undefined' && window.__MSCHF_DEBUG) ||\n    /(^|[?&])mschfDebug=1(&|$)/.test(q)\n  );\n  const SID = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2,7)}`;\n  const C = { mount:0, retire:0, composeInitial:0, recompose:0, rare:0, io:0, beats:0, bars:0 };\n  const qparam = (name) => { try { return new URLSearchParams(q).get(name); } catch { return null; } };\n  const log = (...a) => { if (DEBUG) try { console.log('[MSCHF]', ...a); } catch {} };\n  const warn = (...a) => { if (DEBUG) try { console.warn('[MSCHF]', ...a); } catch {} };\n  const group = (label) => DEBUG && console.groupCollapsed && console.groupCollapsed(`[MSCHF] ${label}`);\n  const groupEnd = () => DEBUG && console.groupEnd && console.groupEnd();\n  try { if (DEBUG) console.info('[MSCHF] Debug ON — session', SID); } catch {}\n\n  // ————————————————————————————————————————\n  // Guards / kill switch\n  // ————————————————————————————————————————\n  const scope = document.body || document.documentElement;\n  if (!scope) return;\n  if (scope.dataset.mschf === 'off') return;\n  if (localStorage.getItem('mschf:off') === '1') return;\n  if (DEBUG) { scope.dataset.mschfDebug = '1'; log('Booting overlay…', { session: SID, dataset: { ...scope.dataset } }); }\n\n  // ————————————————————————————————————————\n  // Utilities\n  // ————————————————————————————————————————\n  const clamp = (v, a, b) => Math.min(b, Math.max(a, v));\n  const lerp  = (a, b, t) => a + (b - a) * t;\n  const now   = () => performance.now();\n  const pick  = (arr) => arr[Math.floor(Math.random() * arr.length)];\n  const css   = (el, obj) => { for (const k in obj) el.style[k] = obj[k]; return el; };\n  const el    = (tag, cls, parent) => {\n    const n = document.createElement(tag);\n    if (cls) n.className = cls;\n    (parent||document.body).appendChild(n);\n    // harden pass-through on *every* node we create\n    n.style.pointerEvents = 'none';\n    n.style.userSelect = 'none';\n    // Debug tagging: attach actor metadata to all created nodes during a mount()\n    try {\n      if (State && State._mountCtx) {\n        n.dataset.mschf = '1';\n        n.dataset.mschfKind = State._mountCtx.kind || 'unknown';\n        n.dataset.mschfFamily = State._mountCtx.family || 'unknown';\n        n.dataset.mschfId = String(State._mountCtx.id || '0');\n        // helper classes for quick CSS targeting\n        if (State._mountCtx.kind) n.classList.add(`mschf-k-${State._mountCtx.kind}`);\n        if (State._mountCtx.family) n.classList.add(`mschf-f-${State._mountCtx.family}`);\n      }\n    } catch {}\n    return n;\n  };\n\n  // External dep loader (PixiJS v8)\n  async function loadPixi() {\n    if (globalThis.PIXI && globalThis.PIXI.Application) return globalThis.PIXI;\n    const sources = [\n      'https://cdn.jsdelivr.net/npm/pixi.js@8.2.1/dist/pixi.min.mjs',\n      'https://esm.sh/pixi.js@8',\n      'https://cdn.skypack.dev/pixi.js@8'\n    ];\n    for (const src of sources) {\n      try { const mod = await import(/* @vite-ignore */ src); return mod.default || mod; } catch {}\n    }\n    return null;\n  }\n\n  function resolveBlend(PIXI, name) {\n    const map = PIXI?.BLEND_MODES;\n    return map && map[name] !== undefined ? map[name] : name.toLowerCase().replace(/_/g, '-');\n  }\n\n  // ————————————————————————————————————————\n  // Global State\n  // ————————————————————————————————————————\n  const State = {\n    root: null, domLayer: null, app: null,\n    style: scope.dataset.mschfStyle || 'auto',\n    densityToken: scope.dataset.mschfDensity || 'calm',\n    density: 0.38, // gentler default\n    mood: 'calm', // calm → lite → bold → loud → storm → studio\n    tempo: 1.0,\n    reduceMotion: matchMedia?.('(prefers-reduced-motion: reduce)').matches || false,\n    reduceData: !!(navigator.connection && (navigator.connection.saveData || /2g/.test(navigator.connection.effectiveType||''))),\n    visible: !document.hidden,\n    nodeBudget: 120, nodeCount: 0,\n    actors: new Set(),\n    families: { scaffold: new Set(), ephemera: new Set(), lab: new Set(), frame: new Set() },\n    beats: { last: now(), dur: 680 },\n    bars:  { last: now(), dur: 4200 },\n    safeZones: [],\n    occupancy: [],\n    actorBoxes: new Map(), // id -> rect {x,y,w,h}\n    cornerSlots: { tl:null, tr:null, bl:null, br:null },\n    readingPressure: 0,\n    gridCols: 10,\n    gridRows: 6,\n    paused: false,\n    fps: { samples: [], bad: false },\n    tiers: { xs: false, sm: false, md: false, lg: false },\n    // hard caps per family to bound DOM churn; recomputed by tier/pressure\n    caps: { scaffold: 6, ephemera: 6, lab: 4, frame: 5 },\n    alpha: 0.85, // overall overlay alpha (debuggable)\n    gpu: { maskOn: true, stageAlpha: 1.0 },\n    // runtime config knobs\n    config: {\n      // 'once' (default): single recomposition; 'auto': periodic; 'off': never after initial\n      recompose: (scope.dataset.mschfRecompose || qparam('mschfRecompose') || 'once').toLowerCase(),\n      // Default rare moments OFF; enable with data-mschf-rare=\"1\" or ?mschfRare=1\n      rare: (() => { const a = scope.dataset.mschfRare; const b = qparam('mschfRare'); return a !== undefined ? a === '1' : b === '1'; })(),\n      // Visual toggles for specific lab elements\n      rings: (() => { const a = scope.dataset.mschfRings; const p = qparam('mschfRings'); return a!=null ? a!=='0' : (p!=null ? p!=='0' : true); })(),\n      topo:  (() => { const a = scope.dataset.mschfTopo;  const p = qparam('mschfTopo');  return a!=null ? a!=='0' : (p!=null ? p!=='0' : true); })(),\n      // GPU-layer toggles (default off for calm sites)\n      gpuRings: (() => { const a = scope.dataset.mschfGpuRings; const p = qparam('mschfGpuRings'); return a!=null ? a!=='0' : (p!=null ? p!=='0' : false); })(),\n      gpuTopo:  (() => { const a = scope.dataset.mschfGpuTopo;  const p = qparam('mschfGpuTopo');  return a!=null ? a!=='0' : (p!=null ? p!=='0' : false); })(),\n      gpuStars: (() => { const a = scope.dataset.mschfGpuStars; const p = qparam('mschfGpuStars'); return a!=null ? a!=='0' : (p!=null ? p!=='0' : false); })(),\n    },\n    _didRecompose: false,\n    _t0: now(),\n    debug: {\n      // Aggressive when DEBUG=true (?mschfDebug=1), quiet otherwise\n      labelsOn: (() => { const p = qparam('mschfLabels'); const d = scope.dataset.mschfLabels; return (p!=null? p!=='0' : (d!=null? d!=='0' : DEBUG)); })(),\n      hudOn:     (() => { const p = qparam('mschfHUD');    const d = scope.dataset.mschfHud;   return (p!=null? p!=='0' : (d!=null? d!=='0' : DEBUG)); })(),\n      autoPick:  (() => { const p = qparam('mschfAutoPick'); const d = scope.dataset.mschfPick; return (p!=null? p!=='0' : (d!=null? d!=='0' : DEBUG)); })(),\n      lastLabelUpdate: 0,\n    },\n    _labels: new Map(),\n    labelLayer: null,\n    hud: null,\n  };\n\n  // Density from token (softened a touch)\n  const densityMap = { calm: 0.22, lite: 0.38, bold: 0.58, loud: 0.75 };\n  if (densityMap[State.densityToken]) State.density = densityMap[State.densityToken];\n\n  // Style: default to calm+structural for clarity\n  if (State.style === 'auto') State.style = 'structural';\n\n  // ————————————————————————————————————————\n  // Root mount\n  // ————————————————————————————————————————\n  function mountRoot() {\n    let root = document.getElementById('mschf-overlay-root');\n    if (!root) { root = el('div','',document.body); root.id = 'mschf-overlay-root'; DEBUG && log('Created overlay root'); }\n    else { DEBUG && log('Reusing overlay root', { childCount: root.childElementCount }); }\n    css(root, {\n      pointerEvents:'none', userSelect:'none',\n      position:'fixed', inset:'0', width:'100vw', height:'100vh',\n      zIndex: getComputedStyle(document.documentElement).getPropertyValue('--mschf-z')?.trim() || '44',\n      color:'currentColor', contain:'layout style paint', contentVisibility:'auto',\n      opacity: State.alpha // global soften\n    });\n    root.setAttribute('aria-hidden','true');\n    root.dataset.mschfSession = SID;\n    if (root.childElementCount) DEBUG && warn('Root was not empty before mount; clearing');\n    root.innerHTML = '';\n    const domLayer = el('div','mschf-layer',root);\n    css(domLayer,{ position:'absolute', inset:0, pointerEvents:'none', userSelect:'none' });\n    // dev label layer\n    const labelLayer = el('div','mschf-devlayer',root);\n    css(labelLayer,{ position:'absolute', inset:0, pointerEvents:'none', userSelect:'none' });\n    const hud = el('div','mschf-hud',root);\n    css(hud,{ position:'fixed', left:'6px', top:'6px', pointerEvents:'none', userSelect:'none', zIndex: '999999', color:'#00ff41', background:'rgba(0,0,0,.58)', border:'1px solid rgba(0,255,65,.6)', borderRadius:'6px', padding:'6px 8px', font:'700 10px/1.2 ui-monospace,Menlo,monospace', letterSpacing:'.06em' });\n    if (!State.debug.hudOn) { hud.style.display = 'none'; }\n    State.root = root; State.domLayer = domLayer; State.labelLayer = labelLayer; State.hud = hud;\n    if (DEBUG && 'MutationObserver' in window) {\n      const mo = new MutationObserver((muts)=>{\n        let added=0, removed=0; for (const m of muts){ added += (m.addedNodes?.length||0); removed += (m.removedNodes?.length||0); }\n        if (added||removed) log('DOM layer mutation', {\n          added, removed, childCount: State.domLayer?.childElementCount||0,\n          actors: State.actors.size,\n          families: { scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size },\n          caps: State.caps, nodeBudget: State.nodeBudget, nodeCount: State.nodeCount\n        });\n      });\n      mo.observe(domLayer, { childList: true });\n      State._mo = mo;\n    }\n  }\n\n  // ————————————————————————————————————————\n  // Mobile tiers + budgets\n  // ————————————————————————————————————————\n  function computeTiers() {\n    const w = innerWidth;\n    State.tiers.xs = w < 480;\n    State.tiers.sm = w >= 480 && w < 768;\n    State.tiers.md = w >= 768 && w < 1024;\n    State.tiers.lg = w >= 1024;\n\n    // tiered budgets\n    State.nodeBudget = State.tiers.lg ? 110 : State.tiers.md ? 90 : 60;\n    if (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) State.nodeBudget = Math.min(State.nodeBudget, 70);\n\n    computeCaps();\n  }\n\n  // ————————————————————————————————————————\n  // Safe zones & placement\n  // ————————————————————————————————————————\n  function computeSafeZones() {\n    const selFallback = '.prose, main, article, header, nav, .map-cta, [data-safe], [data-mschf-safe], [data-occlude=\"avoid\"]';\n    const sel = scope.getAttribute('data-mschf-safe') || selFallback;\n    const pad = 24; // ↑ from 16\n    const rects = [...document.querySelectorAll(sel)]\n      .map(n => n.getBoundingClientRect())\n      .filter(r => r.width * r.height > 0)\n      .map(r => ({\n        x: clamp(r.left - pad, 0, innerWidth),\n        y: clamp(r.top - pad, 0, innerHeight),\n        w: clamp(r.width + pad*2, 0, innerWidth),\n        h: clamp(r.height + pad*2, 0, innerHeight)\n      }));\n    State.safeZones = rects;\n    GPU.updateMask(); // keep GPU from painting over prose\n  }\n\n  // Clip each rect to the viewport; measure visible text only\n  function computeReadingPressure() {\n    const W = innerWidth, H = innerHeight;\n    const clip = r =>\n      Math.max(0, Math.min(r.right, W) - Math.max(r.left, 0)) *\n      Math.max(0, Math.min(r.bottom, H) - Math.max(r.top, 0));\n\n    let area = 0;\n    document.querySelectorAll('p, li, blockquote').forEach(n => {\n      const r = n.getBoundingClientRect();\n      area += clip(r);\n    });\n    const total = W * H || 1;\n    State.readingPressure = clamp(area / total, 0, 1);\n  }\n  function computeContext(){ computeSafeZones(); computeReadingPressure(); computeCaps(); }\n\n  // Recompute per-family caps by tier, density, motion, and reading pressure\n  function computeCaps(){\n    const base = State.tiers.lg ? { ephemera: 8, lab: 6, frame: 6 }\n               : State.tiers.md ? { ephemera: 6, lab: 4, frame: 5 }\n               :                  { ephemera: 3, lab: 2, frame: 3 };\n    const pressureMod = State.readingPressure > 0.25 ? 0.6 : 1.0;\n    const motionMod   = State.reduceMotion ? 0.75 : 1.0;\n    const densityMod  = lerp(0.6, 1.0, clamp(State.density, 0.2, 0.8));\n    State.caps = {\n      scaffold: 6,\n      ephemera: Math.max(1, Math.floor(base.ephemera * pressureMod * motionMod * densityMod)),\n      lab:      Math.max(1, Math.floor(base.lab      * pressureMod * motionMod * densityMod)),\n      frame:    Math.max(1, Math.floor(base.frame    * pressureMod * motionMod * densityMod)),\n    };\n  }\n  function rectOverlap(a,b) {\n    const x = Math.max(0, Math.min(a.x+a.w, b.x+b.w) - Math.max(a.x, b.x));\n    const y = Math.max(0, Math.min(a.y+a.h, b.y+b.h) - Math.max(a.y, b.y));\n    return x*y;\n  }\n  function collidesSafe(r) {\n    const area = Math.max(1, r.w * r.h);\n    for (const z of State.safeZones) if (rectOverlap(r,z)/area > 0.02) return true; // stricter\n    return false;\n  }\n  function collidesActors(r){\n    const area = Math.max(1, r.w * r.h);\n    for (const [,z] of State.actorBoxes){ if (rectOverlap(r,z)/area > 0.06) return true; }\n    return false;\n  }\n  function collidesAny(r){ return collidesSafe(r) || collidesActors(r); }\n  function resetOccupancy() { State.occupancy = new Array(State.gridCols*State.gridRows).fill(0); }\n  function isCellFree(c,r){ return !State.occupancy[r*State.gridCols + c]; }\n  function claimCell(c,r){ State.occupancy[r*State.gridCols + c] = 1; }\n\n  // Corner occupancy manager — prevents stacking actors in corners\n  const CNR = {\n    all: ['tl','tr','bl','br'],\n    free(){ return this.all.filter(c => !State.cornerSlots[c]); },\n    isFree(c){ return !State.cornerSlots[c]; },\n    can(corners){ return corners.every(c => !State.cornerSlots[c]); },\n    pick(){ const f = this.free(); return f.length ? pick(f) : null; },\n    claim(actor, corners){\n      actor._corners = actor._corners || [];\n      for (const c of corners){ State.cornerSlots[c] = actor; actor._corners.push(c); }\n    },\n    release(actor){ if (!actor || !actor._corners) return; for(const c of actor._corners){ if (State.cornerSlots[c]===actor) State.cornerSlots[c]=null; } actor._corners.length=0; }\n  };\n\n  // Zoned placement with optional affinity\n  function findSpot(w,h,aff='anywhere') {\n    const tryGutter = () => {\n      const left = Math.random() < 0.5;\n      const x = left ? Math.round(Math.random()*Math.min(innerWidth*0.1, 120)) : Math.round(innerWidth - w - Math.random()*Math.min(innerWidth*0.1, 120));\n      const y = Math.round(Math.random()*(innerHeight - h));\n      const rect = { x, y, w, h }; if (!collidesAny(rect)) return rect;\n      return null;\n    };\n    const tryCorners = () => {\n      const pad = 8;\n      const pos = pick(['tl','tr','bl','br']);\n      const x = pos.includes('l') ? pad : innerWidth - w - pad;\n      const y = pos.includes('t') ? pad : innerHeight - h - pad;\n      const rect = { x, y, w, h }; if (!collidesAny(rect)) return rect;\n      return null;\n    };\n    const tryHeader = () => {\n      const pad = 12;\n      const x = Math.round(Math.random()*(innerWidth - w));\n      const y = pad;\n      const rect = { x, y, w, h }; if (!collidesAny(rect)) return rect;\n      return null;\n    };\n    const primary = aff==='corners'?tryCorners:aff==='gutters'?tryGutter:aff==='header'?tryHeader:null;\n    if (primary) for (let i=0;i<12;i++){ const r=primary(); if (r) return r; }\n    if (aff!=='gutters') for (let i=0;i<8;i++){ const r=tryGutter(); if(r) return r; }\n\n    const maxTry = 28;\n    for (let i=0;i<maxTry;i++) {\n      const cx = Math.floor(Math.random()*State.gridCols);\n      const cy = Math.floor(Math.random()*State.gridRows);\n      if (!isCellFree(cx,cy)) continue;\n      const rx = Math.round((cx/State.gridCols)*innerWidth);\n      const ry = Math.round((cy/State.gridRows)*innerHeight);\n      const rect = { x: clamp(rx - w*0.1, 0, innerWidth - w), y: clamp(ry - h*0.1, 0, innerHeight - h), w, h };\n      if (!collidesAny(rect)) { claimCell(cx,cy); return rect; }\n    }\n    return { x: Math.round(Math.random()*(innerWidth - w)), y: Math.round(Math.random()*(innerHeight - h)), w, h };\n  }\n\n  // ————————————————————————————————————————\n  // Mood machine (calmer + article caps)\n  // ————————————————————————————————————————\n  const moods = ['calm','lite','bold','loud','storm','studio'];\n  function nextMood(cur){\n    const idx = moods.indexOf(cur);\n    const roll = Math.random();\n    let step = roll < 0.7 ? 1 : roll < 0.92 ? 2 : 3; // drift slower\n    if (State.readingPressure < 0.1 && Math.random() < 0.4) step++;\n    let next = moods[Math.min(idx + step, moods.length - 1)];\n    if (State.readingPressure > 0.25 && ['bold','loud','storm','studio'].includes(next)) next = 'lite';\n    return next;\n  }\n  function applyMood(mood){\n    if (State.readingPressure > 0.25 && ['bold','loud','storm','studio'].includes(mood)) mood = 'lite';\n    State.mood = mood;\n\n    const t = { calm:.95, lite:1.0, bold:1.1, loud:1.18, storm:1.25, studio:.95 }[mood] || 1.0;\n    State.tempo = t;\n\n    // calmer bar/beat lengths\n    State.bars.dur  = lerp(3400, 5200, 1/(State.tempo+.01));\n    State.beats.dur = lerp(580,  820,  1/(State.tempo+.01));\n\n    // density settles toward base, then capped by page type\n    const base = { calm:.22, lite:.38, bold:.55, loud:.7, storm:.85, studio:.35 }[mood] || .4;\n    State.density = clamp(lerp(State.density, base, .6), .18, .9);\n\n    const isArticle = !!document.querySelector('.prose,[data-kind=\"spark\"],[data-kind=\"concept\"],[data-kind=\"project\"],article,main .prose');\n    if (isArticle) State.density = Math.min(State.density, .45);\n    if (State.tiers.xs || State.tiers.sm) State.density = Math.min(State.density, .45);\n\n    if (State.root) State.root.dataset.mood = mood;\n\n    // GPU flourish guardrails\n    GPU.toggleGlow(!isArticle && /loud|storm/.test(mood));\n  }\n\n  // ————————————————————————————————————————\n  // GPU (PixiJS) layer — prose-masked\n  // ————————————————————————————————————————\n  const GPU = {\n    app: null, stage: null, rings: null, topo: null, starfield: null, glow: null, maskG: null,\n    async init() {\n      if (State.reduceData) return null;\n      // Only on large screens by default\n      if (!State.tiers.lg) return null;\n      DEBUG && log('GPU.init start');\n      const PIXI = await loadPixi();\n      if (!PIXI) { DEBUG && warn('GPU.init failed: PIXI not available'); return null; }\n\n      const app = new PIXI.Application();\n      await app.init({\n        width: innerWidth, height: innerHeight, antialias: true, autoDensity: true, backgroundAlpha: 0,\n        powerPreference: 'high-performance', useBackBuffer: false,\n        resolution: devicePixelRatio > 2 ? 2 : devicePixelRatio\n      });\n      State.root.appendChild(app.canvas);\n      css(app.canvas, { position:'absolute', inset:0, pointerEvents:'none', userSelect:'none' });\n\n      const stage = app.stage;\n      this.app = app; this.stage = stage;\n      DEBUG && log('GPU.init ok');\n\n      // Mask that punches holes over safe zones (so GPU never overlays prose)\n      this.updateMask();\n\n      // Rings (GPU) — optional\n      if (State.config.gpuRings) {\n        this.rings = this.makeRings(PIXI);\n        stage.addChild(this.rings.container);\n      }\n\n      // Topo (GPU) — optional\n      if (State.config.gpuTopo) {\n        this.topo = this.makeTopo(PIXI);\n        stage.addChild(this.topo.container);\n      }\n\n      // Starfield (very subtle) — optional\n      if (State.config.gpuStars) {\n        this.starfield = this.makeStars(PIXI);\n        stage.addChild(this.starfield.container);\n      }\n\n      // No CRT by default (was visually heavy over text)\n\n      // Context loss handling (recover or gracefully degrade)\n      try {\n        app.canvas.addEventListener('webglcontextlost', (ev)=>{ ev.preventDefault(); State._gpuLost = true; DEBUG && warn('GPU context lost'); }, false);\n        app.canvas.addEventListener('webglcontextrestored', ()=>{ State._gpuLost = false; DEBUG && log('GPU context restored'); this.topo?.resize?.(); this.rings?.resize?.(); this.starfield?.resize?.(); }, false);\n      } catch {}\n\n      // Resize\n      addEventListener('resize', () => {\n        app.renderer.resize(innerWidth, innerHeight);\n        this.rings?.resize(); this.topo?.resize(); this.starfield?.resize();\n        this.updateMask();\n      });\n\n      return app;\n    },\n\n    updateMask() {\n      if (!this.stage || !this.app) return;\n      const PIXI = this.app.renderer.plugins?.graphics?.graphicsFactory?.renderer?.PIXI || globalThis.PIXI;\n      if (!PIXI) return;\n\n      if (!this.maskG) this.maskG = new PIXI.Graphics();\n      this.maskG.clear();\n\n      if (State.gpu.maskOn) {\n        this.maskG.beginFill(0xffffff, 1);\n        this.maskG.drawRect(0,0,innerWidth,innerHeight);\n        for (const z of State.safeZones) {\n          this.maskG.beginHole();\n          this.maskG.drawRoundedRect(z.x, z.y, z.w, z.h, 8);\n          this.maskG.endHole();\n        }\n        this.maskG.endFill();\n        this.stage.mask = this.maskG;\n        if (!this.maskG.parent) this.stage.addChild(this.maskG);\n        DEBUG && log('GPU.mask on', { holes: State.safeZones.length });\n      } else {\n        // mask off\n        if (this.stage.mask) this.stage.mask = null;\n        if (this.maskG.parent) this.maskG.removeFromParent();\n        DEBUG && log('GPU.mask off');\n      }\n    },\n\n    toggleGlow(enable) {\n      if (!this.stage || State.reduceMotion) return;\n      const want = !!enable;\n      if (want && !this.glow) {\n        (async () => {\n          try {\n            const { GlowFilter } = await import('https://cdn.jsdelivr.net/npm/@pixi/filter-glow@5.2.1/dist/filter-glow.min.mjs').catch(()=>({}));\n            if (GlowFilter) {\n              this.glow = new GlowFilter({ distance: 10, outerStrength: 0.18, innerStrength: 0.0, color: 0xffffff, quality: .25 });\n              this.stage.filters = [this.glow];\n            }\n          } catch {}\n        })();\n      } else if (!want && this.glow) {\n        this.stage.filters = null; this.glow = null;\n      }\n    },\n\n    makeRings(PIXI) {\n      const container = new PIXI.Container(); container.alpha = .08; // softer\n      const g = new PIXI.Graphics(); container.addChild(g);\n\n      function draw(cx, cy, baseR, color) {\n        g.clear();\n        g.blendMode = resolveBlend(PIXI,'ADD');\n        g.lineStyle(1, color, 1);\n        for (let i=0;i<3;i++) g.drawCircle(cx, cy, baseR + i*baseR*.33);\n        g.endFill();\n      }\n\n      let cx = innerWidth*0.5, cy = innerHeight*0.28, base = Math.min(innerWidth, innerHeight)*0.052;\n      let tint = 0xffffff;\n\n      function resize(){ cx = innerWidth*0.5; cy = Math.max(64, innerHeight*0.26); base = Math.min(innerWidth, innerHeight)*0.05; }\n      function step(t){\n        if (State.reduceMotion) { draw(cx, cy, base, tint); return; }\n        const beat = 1 + Math.sin(t/1400) * .05 * State.tempo;\n        draw(cx, cy, base*beat, tint);\n      }\n      resize();\n      return { container, step, resize };\n    },\n\n    makeTopo(PIXI) {\n      const container = new PIXI.Container(); container.alpha = .06;\n      const g = new PIXI.Graphics(); container.addChild(g);\n\n      function draw(){\n        g.clear(); g.blendMode = resolveBlend(PIXI,'SCREEN');\n        const w = innerWidth, h = innerHeight;\n        const lines = 14;\n        for (let i=0;i<lines;i++){\n          const y = (h/lines)*i + Math.sin(i*1.23)*4;\n          g.lineStyle(1, 0xffffff, .32);\n          g.moveTo(0, y);\n          for (let x=0;x<=w;x+=28){\n            const yy = y + Math.sin((x*0.01)+(i*0.6))*4 + Math.sin((x*0.031)-(i))*2.5;\n            g.lineTo(x, yy);\n          }\n        }\n      }\n      function resize(){ draw(); }\n      function step(t){\n        if (State.reduceMotion) return;\n        if (Math.random() < 0.015 * State.tempo) draw();\n      }\n      draw();\n      return { container, step, resize };\n    },\n\n    makeStars(PIXI) {\n      const container = new PIXI.Container(); container.alpha = .05;\n      container.blendMode = resolveBlend(PIXI,'SCREEN');\n      const starTex = PIXI.Texture.WHITE;\n      const sprites = [];\n\n      function populate(){\n        container.removeChildren(); sprites.length = 0;\n        const n = Math.floor(40 + (State.density*60) * (State.tiers.lg ? 1 : .6));\n        for (let i=0;i<n;i++){\n          const s = new PIXI.Sprite(starTex);\n          const size = Math.random()*1.6 + .4;\n          s.tint = 0xffffff; s.alpha = Math.random()*.6 + .2;\n          s.width = size; s.height = size;\n          s.x = Math.random()*innerWidth; s.y = Math.random()*innerHeight;\n          container.addChild(s); sprites.push(s);\n        }\n      }\n      function resize(){ populate(); }\n      function step(){\n        if (State.reduceMotion || State.tiers.xs) return;\n        if (Math.random() < 0.25) return;\n        const k = (State.tempo * 0.1) * (State.tiers.lg ? 1 : .6);\n        for (let i=0;i<sprites.length;i+=7){\n          const s = sprites[i];\n          s.y += (Math.random() - .5) * k;\n          s.x += (Math.random() - .5) * k;\n          if (s.x<0) s.x=innerWidth; if (s.x>innerWidth) s.x=0;\n          if (s.y<0) s.y=innerHeight; if (s.y>innerHeight) s.y=0;\n        }\n      }\n      populate();\n      return { container, step, resize };\n    },\n\n    step(t){\n      if (!this.stage) return;\n      this.rings?.step(t);\n      this.topo?.step(t);\n      this.starfield?.step(t);\n      // stage alpha adapts slightly to pressure\n      this.stage.alpha = State.gpu.stageAlpha = lerp(0.75, 1.0, 1 - State.readingPressure*0.5);\n    }\n  };\n\n  // ————————————————————————————————————————\n  // Actor Framework (DOM ornaments)\n  // ————————————————————————————————————————\n  function mount(actor, family){\n    if (!actor) return;\n    if (DEBUG) group(`mount try: ${actor.kind || 'unknown'} → ${family}`);\n\n    // honor budget\n    const cost = actor.cost || 1;\n    if (State.nodeCount + cost > State.nodeBudget) { DEBUG && warn('bail: nodeBudget cap', { nodeCount: State.nodeCount, cost, nodeBudget: State.nodeBudget }); return void(groupEnd()); }\n\n    // family caps: bail if at capacity\n    const cap = (State.caps && State.caps[family]) || Infinity;\n    if (State.families[family] && State.families[family].size >= cap) { DEBUG && warn('bail: family cap', { family, size: State.families[family].size, cap }); return void(groupEnd()); }\n\n    const isArticle = !!document.querySelector('.prose,[data-kind=\"spark\"],[data-kind=\"concept\"],[data-kind=\"project\"],article,main .prose');\n\n    // Preflight: corner occupancy (avoid stacking multiple corner-bound actors)\n    const wantsCorners = (k)=> ['reg','pips','corners'].includes(k||'');\n    if ((actor.kind||'') === 'stickers'){\n      const chosen = CNR.pick();\n      if (!chosen){ DEBUG && warn('bail: no free corner for stickers'); return DEBUG && groupEnd(), false; }\n      actor.corner = chosen; // handed to actor.mount\n      CNR.claim(actor, [chosen]);\n    } else if (wantsCorners(actor.kind)){\n      if (!CNR.can(['tl','tr','bl','br'])){ DEBUG && warn('bail: corners occupied'); return DEBUG && groupEnd(), false; }\n      CNR.claim(actor, ['tl','tr','bl','br']);\n    }\n\n    // small screens: only minimal scaffold & frame affordances\n    if ((State.tiers.xs || State.tiers.sm) && family !== 'scaffold') {\n      const allow = ['frame','corners','rulers','brackets','reg','dims'];\n      if (!allow.includes(actor.kind || '')) { DEBUG && warn('bail: small-screen filter', { kind: actor.kind, family }); return void(groupEnd()); }\n    }\n    // articles: quiet only\n    if (isArticle && family !== 'scaffold') {\n      const quiet = ['tape','quotes','specimen','plate','dims','reg','brackets','stickers'];\n      if (!quiet.includes(actor.kind || '') && State.density > .45) { DEBUG && warn('bail: article quiet filter', { kind: actor.kind, density: State.density }); return void(groupEnd()); }\n    }\n\n    // assign uid and expose mount context for debug tagging\n    actor._id = (State.seq = (State.seq||0) + 1);\n    State._mountCtx = { id: actor._id, kind: actor.kind, family };\n    State.families[family].add(actor);\n    State.actors.add(actor);\n    State.nodeCount += cost;\n    try { actor.mount(State.domLayer); } catch (e) { DEBUG && warn('actor.mount threw', e); CNR.release(actor); return DEBUG && groupEnd(), false; }\n    // record bounding box to discourage future overlaps\n    try {\n      const r = actor.node?.getBoundingClientRect?.();\n      if (r && isFinite(r.width) && isFinite(r.height)) {\n        const rect = { x: Math.max(0, r.left), y: Math.max(0, r.top), w: Math.max(0, r.width), h: Math.max(0, r.height) };\n        State.actorBoxes.set(actor._id, rect);\n      }\n    } catch {}\n    State._mountCtx = null;\n    // If primary node exists, tag it too\n    try {\n      if (actor.node && actor.node.nodeType === 1) {\n        actor.node.dataset.mschf = '1';\n        actor.node.dataset.mschfKind = actor.kind || 'unknown';\n        actor.node.dataset.mschfFamily = family;\n        actor.node.dataset.mschfId = String(actor._id);\n        actor.node.classList.add(`mschf-k-${actor.kind||'unknown'}`, `mschf-f-${family}`);\n      }\n    } catch {}\n    C.mount++;\n    // text and bbox for quicker mapping\n    let text='';\n    try { text = (actor.node && actor.node.textContent || '').trim().slice(0,48); } catch {}\n    let bbox=null; try { const r = actor.node?.getBoundingClientRect?.(); if (r) bbox = { x:Math.round(r.x), y:Math.round(r.y), w:Math.round(r.width), h:Math.round(r.height) }; } catch {}\n    DEBUG && log('mounted', { id: actor._id, kind: actor.kind, family, text, bbox, node: actor.node, cost, nodeCount: State.nodeCount, sizes: {\n      scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size\n    }});\n    DEBUG && groupEnd();\n    return true;\n  }\n  function retire(actor){\n    if (!actor) return;\n    if (DEBUG) group(`retire: ${actor.kind || 'unknown'}`);\n    try { actor.retire && actor.retire(); } catch (e) { DEBUG && warn('actor.retire threw', e); }\n    try { actor.node && actor.node.remove(); } catch {}\n    try { State.actorBoxes.delete(actor._id); } catch {}\n    try { CNR.release(actor); } catch {}\n    try { const lab = State._labels.get(actor._id); if (lab) { lab.remove(); State._labels.delete(actor._id); } } catch {}\n    State.actors.delete(actor);\n    for (const k in State.families) State.families[k].delete(actor);\n    State.nodeCount = Math.max(0, State.nodeCount - (actor.cost || 1));\n    C.retire++;\n    DEBUG && log('retired', { id: actor._id, kind: actor.kind, nodeCount: State.nodeCount, sizes: {\n      scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size\n    }});\n    DEBUG && groupEnd();\n  }\n\n  const A = {}; // actor factory bag\n\n  // Scaffold (always gentle + pass-through nodes already enforced by el())\n  const gridMeta = { affinity:'anywhere', complexity:2 };\n  A.grid = () => {\n    let node; return {\n      kind:'grid', cost:1, ...gridMeta,\n      mount(p){ node = el('div','mschf-grid',p); node.dataset.variant = Math.random()<.5?'dots':'lines'; },\n      update(){ if (Math.random()< .0015 * State.tempo) node.dataset.variant = node.dataset.variant==='dots'?'lines':'dots'; },\n      node\n    };\n  };\n  A.grid.meta = gridMeta;\n  const frameMeta = { affinity:'anywhere', complexity:2 };\n  A.frame = () => {\n    let node; return {\n      kind:'frame', cost:1, ...frameMeta,\n      mount(p){ node = el('div','mschf-frame',p); },\n      update(t){ node.style.setProperty('--mschf-glow', (0.10 + Math.sin(t/2600)*0.04*State.tempo).toFixed(3)); },\n      node\n    };\n  };\n  A.frame.meta = frameMeta;\n  const cornersMeta = { affinity:'corners', complexity:1 };\n  A.corners = () => {\n    const nodes=[]; return {\n      kind:'corners', cost:1, ...cornersMeta,\n      mount(p){ ['tl','tr','bl','br'].forEach(pos=>nodes.push(el('div',`mschf-corner mschf-corner-${pos}`,p))); },\n      node:{ remove(){ nodes.forEach(n=>n.remove()); } }\n    };\n  };\n  A.corners.meta = cornersMeta;\n  const rulersMeta = { affinity:'anywhere', complexity:1 };\n  A.rulers = () => {\n    let top,left; return {\n      kind:'rulers', cost:1, ...rulersMeta,\n      mount(p){ top=el('div','mschf-ruler mschf-ruler-top',p); left=el('div','mschf-ruler mschf-ruler-left',p); },\n      node:{ remove(){ top.remove(); left.remove(); } }\n    };\n  };\n  A.rulers.meta = rulersMeta;\n  const scanMeta = { affinity:'anywhere', complexity:2 };\n  A.scanline = () => {\n    let node; return {\n      kind:'scan', cost:1, ...scanMeta,\n      mount(p){ node = el('div','mschf-scanline',p); if (State.reduceMotion) node.classList.add('static'); },\n      update(){ if (!State.reduceMotion && Math.random()<0.0015) node.classList.toggle('static', Math.random()<0.5); },\n      node\n    };\n  };\n  A.scanline.meta = scanMeta;\n\n  // Ephemera (mostly gutters/corners)\n  const TAPE_LEX = [\n    '\"KEEP OFF\"','\"FOR RESEARCH ONLY\"','\"SANDBOX\"','\"SPECIMEN\"','\"ARCHIVE\"','\"EVIDENCE\"','\"PROTOTYPE\"',\n    '\"ALPHA\"','\"BETA\"','\"RC1\"','\"NIGHTLY\"','\"CANARY\"','\"WIP\"','\"READ ONLY\"','\"NO INDEX\"',\n    '\"GRAPH\"','\"VECTOR\"','\"RAG\"','\"EVAL\"','\"INTERFACE\"','\"ATLAS\"','\"SPARK\"'\n  ];\n  const tapeMeta = { affinity:'corners', complexity:2 };\n  A.tape = () => {\n    let node, rect={x:0,y:0,w:0,h:0}, life=1;\n    return {\n      kind:'tape', cost:1, ...tapeMeta,\n      mount(p){\n        node = el('div','mschf-tape',p);\n        node.classList.add(pick(['tone-a','tone-b','tone-c']));\n        node.textContent = `${pick(TAPE_LEX)} • RIG-${Math.floor(Math.random()*0xffff).toString(16).padStart(4,'0').toUpperCase()}`;\n        if (Math.random() < (/(bold|loud|storm)/.test(State.mood)?0.35:0.15)) node.dataset.hazard='1';\n        if (Math.random() < 0.14) node.dataset.clear='1';\n        const wvw = Math.round(24 + Math.random()*44);\n        const h = 24 + Math.random()*10;\n        rect = findSpot(innerWidth*(wvw/100), h, this.affinity);\n        const rot = (Math.random()-0.5) * (/(loud|storm)/.test(State.mood)?12:5);\n        css(node,{ top:rect.y+'px', left:rect.x+'px', width:wvw+'vw', transform:`rotate(${rot}deg)`, opacity: State.mood==='calm'?'.18':'.28' });\n      },\n      update(_t,dt){\n        if (State.tiers.xs) return;\n        rect.x = clamp(rect.x + (Math.random()-0.5)*0.28*State.tempo, 0, innerWidth - (node.offsetWidth||0));\n        rect.y = clamp(rect.y + (Math.random()-0.5)*0.20*State.tempo, 0, innerHeight - (node.offsetHeight||0));\n        node.style.left = rect.x+'px'; node.style.top = rect.y+'px';\n        life -= dt * 0.00005 * (0.6 + State.tempo);\n        if (life < 0) this.dead = true;\n      },\n      retire(){ node.classList.add('out'); },\n      node\n    };\n  };\n  A.tape.meta = tapeMeta;\n\n  const STAMPS = ['LAB DROP','EXPERIMENTAL','UNSTABLE','READ ONLY','DECLASSIFIED','NONCANON','INTERNAL','RETRY','RECALIBRATE','ARCHIVE ONLY'];\n  const stampMeta = { affinity:'corners', complexity:2 };\n  A.stamp = () => {\n    let node; return {\n      kind:'stamp', cost:1, ...stampMeta,\n      mount(p){\n        node = el('div','mschf-stamp',p); node.textContent = pick(STAMPS);\n        const pos = pick(['top-right','top-left','bottom-right','bottom-left']);\n        const rot = (Math.random()-0.5)*10, ix=6+Math.floor(Math.random()*14), iy=8+Math.floor(Math.random()*16);\n        const s={ transform:`rotate(${rot}deg)` };\n        if (pos.includes('top')) s.top=iy+'%'; else s.bottom=iy+'%';\n        if (pos.includes('right')) s.right=ix+'%'; else s.left=ix+'%';\n        css(node, s);\n      },\n      node\n    };\n  };\n  A.stamp.meta = stampMeta;\n\n  const quotesMeta = { affinity:'anywhere', complexity:1 };\n  A.quotes = () => {\n    let node; return {\n      kind:'quotes', cost:1, ...quotesMeta,\n      mount(p){\n        node = el('div','mschf-quotes',p);\n        const idtail = Math.random().toString(36).slice(2,5).toUpperCase();\n        node.textContent = `${pick(['\"OBJECT\"','\"INTERFACE\"','\"ARTIFACT\"','\"SYSTEM\"','\"SPECIMEN\"','\"SANDBOX\"','\"VECTOR\"','\"EMBEDDING\"','\"RAG\"','\"EVAL\"'])} • ${idtail}`;\n        const side = Math.random()<0.5?'right':'left', vertical = Math.random()<0.3?'top':'bottom';\n        const offX = 12 + Math.floor(Math.random()*24), offY = 10 + Math.floor(Math.random()*18);\n        const s={}; if(side==='right') s.right=offX+'px'; else s.left=offX+'px'; if(vertical==='top') s.top=offY+'px'; else s.bottom=offY+'px';\n        s.transform = `rotate(${(Math.random()-0.5)*2.0}deg)`; css(node,s);\n      },\n      node\n    };\n  };\n  A.quotes.meta = quotesMeta;\n\n  const plateMeta = { affinity:'gutters', complexity:3 };\n  A.plate = () => {\n    let node, code; return {\n      kind:'plate', cost:1, ...plateMeta,\n      mount(p){\n        node = el('div','mschf-plate',p); el('div','mschf-barcode',node); code = el('div','mschf-code',node);\n        const tail = Math.random().toString(16).slice(-6).toUpperCase();\n        const stamp = new Date().toISOString().slice(0,10);\n        code.textContent = `SEED:${tail} • ${document.body.dataset.buildBranch || 'BR:main'} • ${stamp}`;\n        css(node,{ left:'18px', top:'18px' });\n      },\n      node\n    };\n  };\n  A.plate.meta = plateMeta;\n\n  const specimenMeta = { affinity:'gutters', complexity:2 };\n  A.specimen = () => {\n    let node; return {\n      kind:'specimen', cost:1, ...specimenMeta,\n      mount(p){\n        node = el('div','mschf-specimen',p);\n        const id = Math.random().toString(36).slice(2,7).toUpperCase();\n        const hash = (document.body.dataset.buildHash||'').slice(0,7);\n        const date = (document.body.dataset.builtAt || new Date().toISOString()).slice(0,10);\n        const branch = document.body.dataset.buildBranch || 'main';\n        const rev = pick(['A','B','C','D']);\n        const path = location?.pathname || '/';\n        node.innerHTML = `<strong>SPECIMEN</strong><span>ID ${id}</span>${hash?`<span>BUILD ${hash}</span>`:''}<span>${date}</span><span>BR ${branch}</span><span>REV ${rev}</span><span>PATH ${path}</span>`;\n        const side = Math.random()<0.5?'right':'left', offX = 18+Math.floor(Math.random()*24), offY = 16+Math.floor(Math.random()*20);\n        const s={}; if(side==='right') s.right=offX+'px'; else s.left=offX+'px'; s.top=offY+'px'; css(node,s);\n      },\n      node\n    };\n  };\n  A.specimen.meta = specimenMeta;\n\n  // Lab / blueprint\n  const calloutMeta = { affinity:'gutters', complexity:1 };\n  A.callout = () => {\n    let node; return {\n      kind:'callout', cost:1, ...calloutMeta,\n      mount(p){\n        node = el('div','mschf-callout',p);\n        const labels = ['NODE','EDGE','VECTOR','EVAL','β','Δt','ID'];\n        const val = Math.random().toString(36).slice(2,5).toUpperCase();\n        node.textContent = `${pick(labels)} ${val} • ${(Math.random()*0.99).toFixed(2)}`;\n\n        // Place in a safe, non-overlapping spot (avoid prose)\n        // Temporarily attach for measurement\n        node.style.visibility = 'hidden';\n        requestAnimationFrame(()=>{\n          try{\n            const r = node.getBoundingClientRect();\n            const spot = findSpot(Math.max(60, r.width||120), Math.max(18, r.height||18), 'gutters');\n            node.style.setProperty('--x', `${(spot.x/innerWidth)*100}vw`);\n            node.style.setProperty('--y', `${(spot.y/innerHeight)*100}vh`);\n            const len = 6 + Math.random()*10; node.style.setProperty('--len', `${len}vh`);\n            node.style.visibility = '';\n          } catch { node.style.visibility=''; }\n        });\n      },\n      update(t){\n        if (!node) return;\n        const base = /(loud|storm|studio)/.test(State.mood)? .74 : .66;\n        const o = lerp(base*0.6, base, 1 - clamp(State.readingPressure,0,1));\n        node.style.setProperty('--o', o.toFixed(3));\n        if (State.reduceMotion) return;\n        // very subtle glow “breath”\n        if (Math.random()<0.02) node.style.filter = `drop-shadow(0 0 ${Math.random()<0.5?4:6}px color-mix(in oklab, currentColor 40%, transparent))`;\n      },\n      node\n    };\n  };\n  A.callout.meta = calloutMeta;\n\n  const graphMeta = { affinity:'gutters', complexity:5 };\n  A.graph = () => {\n    let cluster, nodes=[], edges=[]; return {\n      kind:'graph', cost:2, ...graphMeta,\n      mount(p){\n        cluster = el('div','mschf-graph',p);\n        const n = 4 + Math.floor(Math.random()*(/(loud|storm)/.test(State.mood)?8:6));\n        for (let i=0;i<n;i++){ const s=el('span','mschf-graph-node',cluster); s.style.setProperty('--x', `${Math.random()*100}vw`); s.style.setProperty('--y', `${Math.random()*100}vh`); nodes.push(s); }\n        const m = 2 + Math.floor(Math.random()*4);\n        for (let i=0;i<m;i++){ const e=el('i','mschf-graph-edge',cluster); e.style.setProperty('--x1', `${Math.random()*100}vw`); e.style.setProperty('--y1', `${Math.random()*100}vh`); e.style.setProperty('--x2', `${Math.random()*100}vw`); e.style.setProperty('--y2', `${Math.random()*100}vh`); edges.push(e); }\n      },\n      update(){\n        if (State.reduceMotion) return;\n        for (const s of nodes){\n          const x = parseFloat((s.style.getPropertyValue('--x')||'0vw')) || Math.random()*100;\n          const y = parseFloat((s.style.getPropertyValue('--y')||'0vh')) || Math.random()*100;\n          const nx = clamp(x + (Math.random()-.5)*.5*State.tempo, 0, 100);\n          const ny = clamp(y + (Math.random()-.5)*.5*State.tempo, 0, 100);\n          s.style.setProperty('--x', `${nx}vw`); s.style.setProperty('--y', `${ny}vh`);\n        }\n        if (Math.random()<0.015*State.tempo){\n          const e = pick(edges); if (e){ e.style.setProperty('--x2', `${Math.random()*100}vw`); e.style.setProperty('--y2', `${Math.random()*100}vh`); }\n        }\n      },\n      node:{ remove(){ cluster.remove(); } }\n    };\n  };\n  A.graph.meta = graphMeta;\n\n  const ringsMeta = { affinity:'anywhere', complexity:2 };\n  A.ringsDOM = () => { let node; return { kind:'rings', cost:1, ...ringsMeta, mount(p){ node = el('div','mschf-rings',p); if (State.reduceMotion) node.classList.add('static'); const s = 110 + Math.floor(Math.random()*200); css(node,{ left:`${10+Math.random()*80}%`, top:`${10+Math.random()*70}%`, width:s+'px', height:s+'px' }); }, node }; };\n  A.ringsDOM.meta = ringsMeta;\n  const topoMeta = { affinity:'anywhere', complexity:3 };\n  A.topoDOM = () => { let node; return { kind:'topo', cost:1, ...topoMeta, mount(p){ node=el('div','mschf-topo',p); node.style.setProperty('--rot', `${Math.floor((Math.random()-0.5)*24)}deg`); }, node }; };\n  A.topoDOM.meta = topoMeta;\n  const halftoneMeta = { affinity:'anywhere', complexity:3 };\n  A.halftone = () => { let node; return { kind:'halftone', cost:1, ...halftoneMeta, mount(p){ node=el('div','mschf-halftone '+pick(['tl','tr','bl','br']),p); }, node }; };\n  A.halftone.meta = halftoneMeta;\n\n  const perfMeta = { affinity:'gutters', complexity:2 };\n  A.perf = () => { let node; return { kind:'perf', cost:1, ...perfMeta, mount(p){ node=el('div','mschf-perf',p); node.dataset.side = pick(['top','bottom','left','right']); }, node }; };\n  A.perf.meta = perfMeta;\n\n  const starMeta = { affinity:'anywhere', complexity:4 };\n  A.starfieldDOM = () => { let node; return { kind:'stars', cost:1, ...starMeta, mount(p){ node=el('div','mschf-stars',p); node.style.setProperty('--density', `${0.12 + Math.random()*0.25}`); }, node }; };\n  A.starfieldDOM.meta = starMeta;\n\n  // Frame & stickers\n  const bracketsMeta = { affinity:'corners', complexity:1 };\n  A.brackets = () => {\n    let node; return {\n      kind:'brackets', cost:1, ...bracketsMeta,\n      mount(p){\n        node = el('div','mschf-brackets',p);\n        node.classList.add(pick(['tight','wide']));\n        const isArticle = !!document.querySelector('.prose,article,main .prose');\n        node.dataset.variant = (State.readingPressure>0.18 || isArticle) ? 'lite' : 'bold';\n        const pad = (node.classList.contains('wide')? (2 + Math.random()*2) : (5 + Math.random()*3));\n        const stroke = node.dataset.variant==='lite' ? 2 : 3;\n        node.style.setProperty('--pad', pad+'vmin');\n        node.style.setProperty('--b', stroke+'px');\n      },\n      update(){ if(!node) return; const base = node.dataset.variant==='lite' ? .12 : .18; const o = lerp(base*0.4, base, 1 - clamp(State.readingPressure,0,1)); node.style.setProperty('--o', o.toFixed(3)); },\n      node\n    };\n  };\n  A.brackets.meta = bracketsMeta;\n  const glitchMeta = { affinity:'gutters', complexity:3 };\n  A.glitch = () => { let node; return { kind:'glitch', cost:1, ...glitchMeta, mount(p){ node=el('div','mschf-glitch',p); if (State.reduceMotion) node.classList.add('static'); css(node,{ top:Math.floor(Math.random()*100)+'%', left:0, right:0 }); }, node }; };\n  A.glitch.meta = glitchMeta;\n  const watermarkMeta = { affinity:'header', complexity:2 };\n  A.watermark = () => {\n    let node, inner; const LEX = ['EFFUSION LABS','EXPERIMENTAL','INTERNAL','READ ONLY','NONCANON','SANDBOX','PROTOTYPE','ARCHIVE'];\n    const phrase = () => `${pick(LEX)} • ${pick(LEX)} • ${pick(LEX)} •`;\n    return {\n      kind:'watermark', cost:1, ...watermarkMeta,\n      mount(p){\n        node = el('div','mschf-watermark',p);\n        const isArticle = !!document.querySelector('.prose,article,main .prose');\n        const variant = (State.readingPressure>0.25 || isArticle) ? 'stripe' : pick(['stripe','full']);\n        node.dataset.variant = variant;\n        const rot = (Math.random()<.5? -1:1) * (12 + Math.random()*10);\n        const y = Math.round(8 + Math.random()*74);\n        const h = Math.round(26 + Math.random()*28);\n        node.style.setProperty('--rot', rot+'deg');\n        node.style.setProperty('--y', y+'%');\n        node.style.setProperty('--h', h+'px');\n        node.style.setProperty('--o', (/(loud|storm)/.test(State.mood)? .12 : .08).toString());\n        inner = document.createElement('span'); inner.className='mschf-wm-line';\n        inner.textContent = (phrase()+\" \").repeat(12);\n        node.appendChild(inner);\n      },\n      update(t){\n        if (!node) return; const base = parseFloat(getComputedStyle(node).getPropertyValue('--o')||'0.08')||0.08;\n        const o = lerp(base*0.35, base, 1 - clamp(State.readingPressure,0,1)); node.style.opacity = o.toFixed(3);\n        if (State.reduceMotion) return;\n        const dir = node.dataset.dir || (node.dataset.dir = (Math.random()<.5? '1':'-1'));\n        const speed = (State.tiers.lg? 18:12) * (/(studio|loud)/.test(State.mood)?1.3:1.0);\n        const tx = ((t/1000) * speed * (dir==='1'?1:-1)) % 100; if (inner) inner.style.transform = `translateX(${tx.toFixed(1)}px)`;\n      },\n      node\n    };\n  };\n  A.watermark.meta = watermarkMeta;\n  const flowersMeta = { affinity:'anywhere', complexity:2 };\n  A.flowers = () => { const nodes=[]; return { kind:'flowers', cost:1, ...flowersMeta, mount(p){ const n=1+Math.floor(Math.random()*(/(loud|storm)/.test(State.mood)?2:1)); for(let i=0;i<n;i++){ const fl=el('div','mschf-flower',p); const s=34+Math.floor(Math.random()*26), x=10+Math.floor(Math.random()*80), y=10+Math.floor(Math.random()*70); css(fl,{ width:s+'px', height:s+'px', left:x+'%', top:y+'%', transform:`rotate(${Math.floor((Math.random()-0.5)*160)}deg)` }); nodes.push(fl);} }, node:{ remove(){ nodes.forEach(n=>n.remove()); } } }; };\n  A.flowers.meta = flowersMeta;\n  const holoMeta = { affinity:'gutters', complexity:4 };\n  A.holo = () => { let node; return { kind:'holo', cost:1, ...holoMeta, mount(p){ node=el('div','mschf-holo',p); if (State.reduceMotion) node.classList.add('static'); }, node }; };\n  A.holo.meta = holoMeta;\n  const regMeta = { affinity:'corners', complexity:1 };\n  A.reg = () => { const nodes=[]; return { kind:'reg', cost:1, ...regMeta, mount(p){ ['tl','tr','bl','br'].forEach(pos=>nodes.push(el('div','mschf-reg '+pos,p))); }, node:{ remove(){ nodes.forEach(n=>n.remove()); } } }; };\n  A.reg.meta = regMeta;\n  const dimsMeta = { affinity:'anywhere', complexity:1 };\n  A.dims = () => {\n    let node, label; return {\n      kind:'dims', cost:1, ...dimsMeta,\n      mount(p){\n        node = el('div','mschf-dims',p);\n        // Prefer top/bottom gutters to avoid center text\n        const edgeTop = Math.random() < 0.5;\n        const y = edgeTop ? (8 + Math.random()*12) : (78 + Math.random()*12);\n        const x1 = 6 + Math.floor(Math.random()*24);\n        const span = 24 + Math.floor(Math.random()*32);\n        const x2 = Math.min(92, x1 + span);\n        node.style.setProperty('--x1', `${x1}vw`);\n        node.style.setProperty('--x2', `${x2}vw`);\n        node.style.setProperty('--y', `${y}vh`);\n        node.style.setProperty('--o', (/(loud|storm)/.test(State.mood)? .26 : .22).toString());\n        label = document.createElement('em');\n        label.className = 'mschf-dims-label';\n        label.textContent = `${Math.abs(x2 - x1)}vw`;\n        node.appendChild(label);\n        el('span','',node); // right tick\n      },\n      update(t){\n        if (!node) return;\n        const base = /(studio|loud)/.test(State.mood) ? .22 : .18;\n        const o = lerp(base*0.6, base, 1 - clamp(State.readingPressure,0,1));\n        node.style.setProperty('--o', o.toFixed(3));\n        if (State.reduceMotion || !label) return;\n        const s = 0.98 + Math.sin(t/1200)*0.02; // soft breathing\n        label.style.setProperty('--s', s.toFixed(3));\n      },\n      node\n    };\n  };\n  A.dims.meta = dimsMeta;\n  const stickersMeta = { affinity:'gutters', complexity:3 };\n  A.stickers = () => {\n    let cluster; return {\n      kind:'stickers', cost:1, ...stickersMeta,\n      mount(p){\n        cluster = el('div','mschf-stickers',p);\n        const corner = this.corner || pick(['br','bl','tr','tl']); const off = 18 + Math.floor(Math.random()*18);\n        const s={}; if (corner.includes('b')) s.bottom=off+'px'; else s.top=off+'px'; if (corner.includes('r')) s.right=off+'px'; else s.left=off+'px'; css(cluster,s);\n        const badges = ['ALPHA','BETA','RC1','SIGNED','VOID','UNLOCKED','PASS','LAB','SIM','ARCHIVE','SANDBOX','RAG','EVAL','GRAPH','SPARK','VECTOR','EMBED','SPECIMEN','PROTO'];\n        const n = 2 + Math.floor(Math.random()*3);\n        for (let i=0;i<n;i++){\n          const b = el('span','mschf-badge',cluster); b.textContent = pick(badges);\n          pick([()=>{ b.style.fontSize='10px'; b.style.padding='5px 7px'; },()=>{ b.style.fontSize='11px'; b.style.padding='6px 8px'; },()=>{ b.style.fontSize='12px'; b.style.padding='7px 9px'; }])();\n          b.style.setProperty('--rx', `${Math.floor((Math.random()-0.5)*16)}deg`);\n          b.style.setProperty('--offx', `${Math.floor((Math.random()-0.5)*14)}px`);\n          b.style.setProperty('--offy', `${Math.floor((Math.random()-0.5)*10)}px`);\n          if (Math.random() < .22) b.style.boxShadow='0 0 0 1px color-mix(in oklab, currentColor 35%, transparent), 0 10px 18px rgba(0,0,0,.35)';\n        }\n      },\n      node:{ remove(){ cluster.remove(); } }\n    };\n  };\n  A.stickers.meta = stickersMeta;\n\n  // ————————————————————————————————————————\n  // Frame Enhancements — subtle, procedural, autonomous\n  // ————————————————————————————————————————\n  const edgeMeta = { affinity:'anywhere', complexity:2 };\n  A.edgeGlow = () => {\n    let nodes = [];\n    function make(pos){\n      const n = el('div', `mschf-edge mschf-edge-${pos}` , State.domLayer);\n      return n;\n    }\n    return {\n      kind:'edgeGlow', cost:1, ...edgeMeta,\n      mount(p){ nodes = ['top','right','bottom','left'].map(make); },\n      update(t){\n        const pressure = State.readingPressure || 0; // 0..1\n        const base = /(loud|storm|studio)/.test(State.mood) ? 0.11 : 0.07;\n        const o = Math.max(0.03, base * (1 - pressure*0.8));\n        const k = (State.tempo || 1) * (State.tiers.lg ? 1 : 0.8);\n        const phase = (t/1000) * 0.2 * k; // slow drift\n        for (const n of nodes){\n          n.style.setProperty('--o', o.toFixed(3));\n          n.style.setProperty('--p', (phase % 1).toFixed(3));\n        }\n      },\n      node:{ remove(){ nodes.forEach(n=>n.remove()); } }\n    };\n  };\n  A.edgeGlow.meta = edgeMeta;\n\n  const pipsMeta = { affinity:'corners', complexity:1 };\n  A.cornerPips = () => {\n    const nodes = [];\n    return {\n      kind:'pips', cost:1, ...pipsMeta,\n      mount(p){\n        ['tl','tr','bl','br'].forEach(c=>{\n          const n = el('div', `mschf-pip mschf-pip-${c}`, p);\n          nodes.push(n);\n        });\n      },\n      update(t){\n        if (State.reduceMotion) return;\n        const beat = (Math.sin(t/900) + 1)/2; // 0..1\n        const s = 0.9 + beat*0.15;\n        for (const n of nodes){ n.style.transform = `scale(${s.toFixed(3)})`; }\n      },\n      node:{ remove(){ nodes.forEach(n=>n.remove()); } }\n    };\n  };\n  A.cornerPips.meta = pipsMeta;\n\n  // ————————————————————————————————————————\n  // Orchestration\n  // ————————————————————————————————————————\n  function composeInitial() {\n    DEBUG && group('composeInitial');\n    C.composeInitial++;\n    DEBUG && log('style/mood/density', { style: State.style, mood: State.mood, density: State.density, tiers: { ...State.tiers }, caps: { ...State.caps } });\n    // Scaffold (calm by default)\n    mount(A.grid(),    'scaffold');\n    mount(A.frame(),   'scaffold');\n    mount(A.corners(), 'scaffold');\n    mount(A.rulers(),  'scaffold');\n    // Removed moving scanline by default for readability\n\n    const isArticle = !!document.querySelector('.prose,article,main .prose');\n\n    const waves = {\n      structural: () => { spawnLab(1,2); spawnFrame(1,2); if (!isArticle) spawnEphemera(1,2); },\n      collage:    () => { spawnEphemera(1,3); spawnLab(1,2); spawnFrame(1,2); },\n      playful:    () => { spawnEphemera(2,3); spawnFrame(1,2); }\n    };\n    (waves[State.style] || waves.structural)();\n    const kindsSummary = (fam) => { const m = Object.create(null); for (const a of State.families[fam]) m[a.kind||'unknown']=(m[a.kind||'unknown']||0)+1; return m; };\n    DEBUG && log('post-compose sizes', {\n      scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size,\n      nodeCount: State.nodeCount,\n      kinds: { ephemera: kindsSummary('ephemera'), lab: kindsSummary('lab'), frame: kindsSummary('frame') }\n    });\n    DEBUG && groupEnd();\n  }\n\n  function spawnEphemera(min,max){\n    const bag = [A.tape, A.stamp, A.quotes, A.plate, A.specimen];\n    const pool = State.readingPressure > 0.25 ? bag.filter(f => (f.meta?.complexity || 1) <= 2) : bag;\n    const n = Math.floor(lerp(min, max, State.density));\n    for (let i=0;i<n;i++){ const fn = pick(pool.length?pool:bag); mount(fn(), 'ephemera'); }\n  }\n  function spawnLab(min,max){\n    const gpuOK = !!State.app && !State.reduceData;\n    const base = [A.callout, A.graph, A.perf];\n    const domExtras = [State.config.rings? A.ringsDOM : null, State.config.topo? A.topoDOM : null, A.halftone, A.starfieldDOM].filter(Boolean);\n    const bag = gpuOK ? base : base.concat(domExtras);\n    const pool = State.readingPressure > 0.25 ? bag.filter(f => (f.meta?.complexity || 1) <= 3) : bag;\n    const n = Math.floor(lerp(min, max, State.density));\n    for (let i=0;i<n;i++){ const fn = pick(pool.length?pool:bag); mount(fn(), 'lab'); }\n  }\n  function spawnFrame(min,max){\n    // Calm set plus tasteful autonomous accents\n    const bag = [A.brackets, A.watermark, A.reg, A.dims, A.stickers, A.edgeGlow, A.cornerPips];\n    const pool = State.readingPressure > 0.25 ? bag.filter(f => (f.meta?.complexity || 1) <= 2) : bag;\n    const n = Math.floor(lerp(min, max, State.density));\n    for (let i=0;i<n;i++){\n      const candidates = (pool.length?pool:bag).slice();\n      let placed = false;\n      for (let t=0;t<candidates.length && !placed; t++){\n        const idx = Math.floor(Math.random()*candidates.length);\n        const fn = candidates.splice(idx,1)[0];\n        placed = !!mount(fn(), 'frame');\n      }\n    }\n  }\n\n  function recompose(){\n    DEBUG && group('recompose');\n    C.recompose++;\n    resetOccupancy(); computeContext();\n    const kindsSummary = (fam) => {\n      const m = Object.create(null);\n      for (const a of State.families[fam]) m[a.kind||'unknown'] = (m[a.kind||'unknown']||0)+1;\n      return m;\n    };\n    const sizes = {\n      ephemera: State.families.ephemera.size,\n      lab:      State.families.lab.size,\n      frame:    State.families.frame.size,\n    };\n    DEBUG && log('pre-prune sizes', {\n      scaffold: State.families.scaffold.size,\n      ephemera: sizes.ephemera,\n      lab:      sizes.lab,\n      frame:    sizes.frame,\n      caps: { ...State.caps }, density: State.density, readingPressure: State.readingPressure\n    });\n\n    // Compute stable targets per family based on caps, density, and reading pressure.\n    const d = clamp(State.density, 0.2, 0.9);\n    const pressureMod = State.readingPressure > 0.25 ? 0.6 : 1.0; // quieter when reading\n    const want = {\n      ephemera: Math.min(State.caps.ephemera, Math.round(lerp(1, State.caps.ephemera, d) * pressureMod)),\n      lab:      Math.min(State.caps.lab,      Math.round(lerp(1, State.caps.lab,      d) * pressureMod)),\n      frame:    Math.min(State.caps.frame,    Math.round(lerp(1, State.caps.frame,    d) * pressureMod)),\n    };\n\n    // Prefer to shed high-complexity actors when above target.\n    for (const fam of ['ephemera','lab','frame']){\n      const have = sizes[fam];\n      const needToRemove = Math.max(0, have - want[fam]);\n      if (!needToRemove) continue;\n      const actors = Array.from(State.families[fam]).sort((a,b)=>(b.complexity||1)-(a.complexity||1));\n      for (let i=0;i<needToRemove;i++){ const a = actors[i]; if (a) retire(a); }\n      sizes[fam] -= needToRemove;\n    }\n\n    // Top up gently to targets (idempotent: does nothing once at/over target)\n    const addEphemera = Math.max(0, want.ephemera - sizes.ephemera);\n    const addLab      = Math.max(0, want.lab      - sizes.lab);\n    const addFrame    = Math.max(0, want.frame    - sizes.frame);\n    if (addEphemera) spawnEphemera(addEphemera, addEphemera);\n    if (addLab)      spawnLab(addLab, addLab);\n    if (addFrame)    spawnFrame(addFrame, addFrame);\n\n    DEBUG && log('post-recompose sizes', {\n      scaffold: State.families.scaffold.size,\n      ephemera: State.families.ephemera.size,\n      lab:      State.families.lab.size,\n      frame:    State.families.frame.size,\n      nodeCount: State.nodeCount,\n      kinds: {\n        ephemera: kindsSummary('ephemera'),\n        lab: kindsSummary('lab'),\n        frame: kindsSummary('frame'),\n      }\n    });\n    DEBUG && groupEnd();\n  }\n\n  function rareMoment(){\n    if (State.reduceMotion || State.tiers.xs) return;\n    C.rare++;\n    DEBUG && log('rareMoment');\n    mount(A.holo(), 'frame');\n    for (let i=0;i<2;i++) mount(A.glitch(), 'frame');\n    mount(A.tape(), 'ephemera');\n    setTimeout(()=>mount(A.tape(),'ephemera'), 160);\n  }\n\n  function degradeDensity(){\n    // drop some actors and reduce target density\n    const fams = ['lab','frame','ephemera'];\n    State.density = Math.max(.18, State.density - 0.06);\n    for (const fam of fams) {\n      const n = Math.ceil(State.families[fam].size * 0.3);\n      for (let i=0;i<n;i++){ const a = State.families[fam].values().next().value; if (a) retire(a); }\n      if (!State.fps.bad) break;\n    }\n  }\n\n  // ————————————————————————————————————————\n  // Scheduler\n  // ————————————————————————————————————————\n  function tick(t){\n    if (State.paused) return;\n    requestAnimationFrame(tick);\n    const dt = t - (State._t || t); State._t = t;\n\n    // FPS sentinel (sooner + gentler)\n    const S = State.fps.samples; S.push(dt); if (S.length>18) S.shift();\n    if (S.length===18){\n      const avg = S.reduce((a,b)=>a+b,0)/S.length; State.fps.bad = avg>24; // ~ < 41 FPS\n      if (State.fps.bad) degradeDensity();\n    }\n\n    if (t - State.beats.last > State.beats.dur) { State.beats.last = t; C.beats++; DEBUG && (C.beats % 20 === 0) && log('beat', { beats: C.beats, bars: C.bars }); }\n    if (t - State.bars.last  > State.bars.dur)  {\n      State.bars.last = t; C.bars++;\n      DEBUG && log('bar tick', { bars: C.bars, mood: State.mood, density: State.density, actors: State.actors.size });\n      const mode = State.config.recompose;\n      if (mode === 'auto') {\n        if (Math.random()<.7) applyMood(nextMood(State.mood));\n        recompose();\n        if (State.config.rare && Math.random()<.06) rareMoment();\n      } else if (mode === 'once') {\n        if (!State._didRecompose) { recompose(); State._didRecompose = true; }\n      } else {\n        // 'off' → no periodic recomposition\n      }\n    }\n\n    for (const a of Array.from(State.actors)) {\n      try { a.update && a.update(t, dt); } catch {}\n      if (a.dead) retire(a);\n    }\n    GPU.step(t);\n\n    // Debug dev-labels (throttled)\n    // enforce pass-through unless picking\n    try {\n      if (State.root) State.root.style.pointerEvents = State._picking ? 'auto' : 'none';\n      if (State.domLayer) State.domLayer.style.pointerEvents = State._picking ? 'auto' : 'none';\n      if (State.labelLayer) State.labelLayer.style.pointerEvents = 'none';\n      if (State.app?.canvas) State.app.canvas.style.pointerEvents = 'none';\n    } catch {}\n\n    // GPU self-heal: if desired but lost/absent, try to reinit occasionally\n    try {\n      const wantGPU = !!(State.config.gpuRings || State.config.gpuTopo || State.config.gpuStars);\n      if (wantGPU && (!State.app || State._gpuLost)){\n        const due = !State._gpuRetryAt || t > State._gpuRetryAt;\n        if (due){\n          State._gpuRetryAt = t + 4000; // backoff\n          GPU.init().then(app=>{ if(app){ State._gpuLost=false; DEBUG&&log('GPU reinit ok'); } });\n        }\n      }\n    } catch {}\n\n    if (State.debug.labelsOn) { try { updateDevLabels(); } catch {} }\n    if (State.debug.hudOn)    { try { updateHUD(); } catch {} }\n  }\n\n  // ————————————————————————————————————————\n  // Observers & context\n  // ————————————————————————————————————————\n  function updateDevLabels(){\n    if (!State.labelLayer) return;\n    const seen = new Set();\n    for (const a of State.actors){\n      if (!a || !a.node || !a.node.getBoundingClientRect) continue;\n      const id = a._id;\n      seen.add(id);\n      let lab = State._labels.get(id);\n      if (!lab){\n        lab = document.createElement('div');\n        lab.className = 'mschf-devlabel';\n        lab.style.cssText = 'position:fixed;z-index:999999;font:700 10px/1 ui-monospace,Menlo,monospace;letter-spacing:.06em;color:#00ff41;background:rgba(0,0,0,.6);border:1px solid rgba(0,255,65,.6);padding:2px 4px;border-radius:4px;pointer-events:none;user-select:none;';\n        State.labelLayer.appendChild(lab);\n        State._labels.set(id, lab);\n      }\n      const r = a.node.getBoundingClientRect();\n      lab.style.left = Math.round(r.left + 2) + 'px';\n      lab.style.top  = Math.round(r.top  + 2) + 'px';\n      const txt = `#${id} ${a.kind||'?'} @${Object.entries(State.families).find(([,set])=>set.has(a))?.[0]||'?'}${(a.node?.textContent?.trim()?` — ${a.node.textContent.trim().slice(0,18)}`:'')}`;\n      lab.textContent = txt;\n      lab.hidden = false;\n    }\n    // hide labels for retired actors\n    for (const [id, lab] of State._labels){ if (!seen.has(id)) { try{ lab.remove(); }catch{} State._labels.delete(id); } }\n  }\n\n  // Alt-click picking without toggling pointer-events globally\n  function pickFromPoint(x, y){\n    try {\n      const root = State.domLayer || document;\n      const nodes = [...root.querySelectorAll('[data-mschf=\"1\"]')];\n      const hits = nodes.filter(n=>{ const r=n.getBoundingClientRect(); return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom; });\n      const target = hits[hits.length-1]; // last in DOM order ≈ on top\n      if (!target) return false;\n      const id = +target.dataset.mschfId; const kind = target.dataset.mschfKind; const family = target.dataset.mschfFamily;\n      const r = target.getBoundingClientRect();\n      const a = [...State.actors].find(x=>x._id===id);\n      console.log('[MSCHF] pick@point', { id, kind, family, bbox:{x:Math.round(r.x),y:Math.round(r.y),w:Math.round(r.width),h:Math.round(r.height)}, text:(target.textContent||'').trim(), node:target, actor:a });\n      target.classList.add('mschf-highlight'); setTimeout(()=>target.classList.remove('mschf-highlight'), 2000);\n      return true;\n    } catch (e) { DEBUG && warn('pickFromPoint error', e); return false; }\n  }\n\n  function updateHUD(){\n    if (!State.hud) return;\n    State.hud.style.display = 'block';\n    const sizes = {\n      scaffold: State.families.scaffold.size,\n      ephemera: State.families.ephemera.size,\n      lab: State.families.lab.size,\n      frame: State.families.frame.size,\n    };\n    const line1 = `bars:${C.bars} beats:${C.beats} mood:${State.mood} d:${State.density.toFixed(2)}`;\n    const line2 = `scaf:${sizes.scaffold} eph:${sizes.ephemera} lab:${sizes.lab} frame:${sizes.frame}`;\n    const line3 = `actors:${State.actors.size} nodes:${State.nodeCount}`;\n    // brief legend of kinds by frame/ephemera\n    const kinds = (fam)=>{\n      const m = Object.create(null); for (const a of State.families[fam]) m[a.kind||'?']=(m[a.kind||'?']||0)+1; return Object.entries(m).map(([k,v])=>`${k}×${v}`).join(' ');\n    };\n    const line4 = `@ephemera ${kinds('ephemera')}`;\n    const line5 = `@frame ${kinds('frame')}`;\n    State.hud.textContent = `${line1}\\n${line2}\\n${line3}\\n${line4}\\n${line5}`;\n  }\n  function wireSections(){\n    const hero = document.querySelector('.hero,[data-component~=\"hero\"],section[id*=\"hero\"]');\n    const cta  = document.querySelector('.map-cta,[class*=\"map-cta\"],[data-component~=\"map-cta\"]');\n    const feed = document.querySelector('.work-feed,[data-component~=\"work-feed\"]');\n    DEBUG && log('wireSections', { hero: !!hero, cta: !!cta, feed: !!feed });\n\n    // Observe once per section: prevent repeated mounts when crossing thresholds\n    const io = new IntersectionObserver((entries)=>{\n      for (const e of entries){\n        if (!e.isIntersecting) continue;\n        // Skip if we've already handled this target\n        if (e.target?.dataset?.mschfSeen === '1') { io.unobserve(e.target); continue; }\n        C.io++;\n        DEBUG && log('io fired', { which: e.target === hero ? 'hero' : e.target === cta ? 'cta' : e.target === feed ? 'feed' : 'unknown', count: C.io });\n        if (hero && e.target===hero) { if (State.config.rings) mount(A.ringsDOM(),'lab'); mount(A.quotes(),'ephemera'); }\n        if (cta && e.target===cta)   { mount(A.plate(),'ephemera'); if (State.config.rare) rareMoment(); }\n        if (feed && e.target===feed) { mount(A.stickers(),'frame'); mount(A.dims(),'frame'); }\n\n        // Mark handled and stop observing to avoid duplicate mounts\n        try { e.target.dataset.mschfSeen = '1'; io.unobserve(e.target); } catch {}\n      }\n    }, { rootMargin:'0px 0px -20% 0px', threshold:[0.25, 0.6] });\n\n    [hero, cta, feed].filter(Boolean).forEach(n=>io.observe(n));\n  }\n\n  // ————————————————————————————————————————\n  // Visibility & events\n  // ————————————————————————————————————————\n  function onVisibility(){\n    State.visible = !document.hidden;\n    if (!State.visible) State.paused = true;\n    else { State.paused = false; State.beats.last = now(); State.bars.last = now(); DEBUG && log('visibility: resume'); requestAnimationFrame(tick); }\n  }\n\n  // Auto-enable Alt-click picking in DEBUG\n  const _autoPickClick = (ev) => {\n    if (!DEBUG || !State.debug.autoPick) return;\n    if (!ev.altKey) return; // hold Alt/Option to pick\n    // don't let the page handle this click\n    ev.preventDefault(); ev.stopPropagation();\n    pickFromPoint(ev.clientX, ev.clientY);\n  };\n  const _autoPickKey = (ev) => {\n    if (!DEBUG || !State.debug.autoPick || !State.root) return;\n    if (ev.type === 'keydown' && ev.key === 'Alt') State.root.style.cursor = 'crosshair';\n    if (ev.type === 'keyup'   && ev.key === 'Alt') State.root.style.cursor = '';\n  };\n\n  // ————————————————————————————————————————\n  // Boot\n  // ————————————————————————————————————————\n  async function boot(){\n    DEBUG && log('boot()');\n    mountRoot(); computeTiers(); computeContext(); resetOccupancy();\n\n    // GPU init (LG only, not reduced-data, and avoid truly weak CPUs)\n    const weakCPU = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;\n    if (!State.tiers.xs && !State.tiers.sm && !State.reduceData && !weakCPU) {\n      State.app = await GPU.init();\n    }\n\n    // Prefer structural on obvious reading pages\n    if (document.querySelector('.prose,article,main .prose') && State.style === 'collage') State.style = 'structural';\n\n    applyMood(State.mood);\n    composeInitial();\n    wireSections();\n    // In 'once' mode, schedule a single recompose shortly after initial compose\n    if (State.config.recompose === 'once') {\n      setTimeout(() => { if (!State._didRecompose) { try { recompose(); } finally { State._didRecompose = true; } } }, 600);\n    }\n    // Bind debug auto-pick handlers (Alt-click)\n    try {\n      document.addEventListener('click', _autoPickClick, true);\n      document.addEventListener('keydown', _autoPickKey, true);\n      document.addEventListener('keyup', _autoPickKey, true);\n    } catch {}\n    requestAnimationFrame(tick);\n  }\n\n  // Events\n  addEventListener('resize', () => { computeTiers(); computeContext(); resetOccupancy(); });\n  document.addEventListener('visibilitychange', onVisibility, false);\n\n  // Reduced motion/data immediate adjustments\n  if (State.reduceMotion) State.density = Math.min(State.density, .45);\n  if (State.reduceData)   State.density = Math.min(State.density, .4);\n\n  // Start\n  if (document.readyState === 'complete' || document.readyState === 'interactive') requestAnimationFrame(boot);\n  else document.addEventListener('DOMContentLoaded', () => requestAnimationFrame(boot));\n\n  // ————————————————————————————————————————\n  // Console Controls\n  // ————————————————————————————————————————\n  window.__mschfOff = () => { localStorage.setItem('mschf:off','1'); try{ State.root?.remove(); }catch{} };\n  window.__mschfOn  = () => { localStorage.removeItem('mschf:off'); location.reload(); };\n  window.__mschfPulse = () => rareMoment();\n  window.__mschfMood  = (m) => { if (['calm','lite','bold','loud','storm','studio'].includes(m)) applyMood(m); };\n  window.__mschfDensity = (x) => { State.density = clamp(+x||State.density, .1, .9); recompose(); };\n  window.__mschfMask = (on=1) => { State.gpu.maskOn = !!(+on); GPU.updateMask(); };\n  window.__mschfAlpha = (x) => { State.alpha = clamp(+x||State.alpha, 0.3, 1.0); if(State.root) State.root.style.opacity = State.alpha; };\n  window.__mschfDebug = (on=1) => { localStorage.setItem('mschf:debug', on? '1':'0'); location.reload(); };\n  window.__mschfHUD = (on=1) => {\n    State.debug.hudOn = !!(+on);\n    if (State.debug.hudOn) { updateHUD(); }\n    else if(State.hud) { State.hud.textContent=''; State.hud.style.display='none'; }\n  };\n  window.__mschfAutoPick = (on=1) => { State.debug.autoPick = !!(+on); };\n  window.__mschfCull = (kind='rings') => { const culled=[]; for (const a of Array.from(State.actors)){ if ((a.kind||'')===kind){ retire(a); culled.push(a._id); } } console.log('[MSCHF] culled', kind, culled); return culled.length; };\n  window.__mschfToggle = (what, on=1) => {\n    const enable = !!(+on);\n    if (what==='rings') { State.config.rings=enable; if (!enable) __mschfCull('rings'); else recompose(); return; }\n    if (what==='topo')  { State.config.topo=enable;  if (!enable) __mschfCull('topo');  else recompose(); return; }\n    if (!State.app || !GPU.stage) { console.warn('[MSCHF] GPU not active'); return; }\n    const PIXI = globalThis.PIXI;\n    if (what==='gpuRings') {\n      State.config.gpuRings = enable;\n      if (enable && !GPU.rings && PIXI) { GPU.rings = GPU.makeRings(PIXI); GPU.stage.addChild(GPU.rings.container); }\n      if (!enable && GPU.rings) { GPU.rings.container.removeFromParent(); GPU.rings=null; }\n      return;\n    }\n    if (what==='gpuTopo') {\n      State.config.gpuTopo = enable;\n      if (enable && !GPU.topo && PIXI) { GPU.topo = GPU.makeTopo(PIXI); GPU.stage.addChild(GPU.topo.container); }\n      if (!enable && GPU.topo) { GPU.topo.container.removeFromParent(); GPU.topo=null; }\n      return;\n    }\n    if (what==='gpuStars') {\n      State.config.gpuStars = enable;\n      if (enable && !GPU.starfield && PIXI) { GPU.starfield = GPU.makeStars(PIXI); GPU.stage.addChild(GPU.starfield.container); }\n      if (!enable && GPU.starfield) { GPU.starfield.container.removeFromParent(); GPU.starfield=null; }\n      return;\n    }\n  };\n  // Turn on live dev labels: __mschfLabels(1)\n  window.__mschfLabels = (on=1) => { State.debug.labelsOn = !!(+on); if (on) updateDevLabels(); else { for (const [,lab] of State._labels){ try{ lab.remove(); }catch{} } State._labels.clear(); } };\n  // Dump actors to console (optionally filter by '@family' or 'kind')\n  window.__mschfDump = (filter='') => {\n    const norm = String(filter||'').trim();\n    const out = [];\n    for (const a of State.actors){\n      const fam = Object.entries(State.families).find(([,set])=>set.has(a))?.[0]||'?';\n      if (!norm || (norm.startsWith('@') && norm.slice(1)===fam) || (!norm.startsWith('@') && (a.kind||'')===norm)){\n        const r = a.node?.getBoundingClientRect?.();\n        out.push({ id:a._id, kind:a.kind, family:fam, complexity:a.complexity||1, text:(a.node?.textContent||'').trim().slice(0,48), bbox:r?{x:Math.round(r.x),y:Math.round(r.y),w:Math.round(r.width),h:Math.round(r.height)}:null, node:a.node });\n      }\n    }\n    console.table(out);\n    return out;\n  };\n  // Highlight matches for a few seconds: __mschfSelect('stamp') or __mschfSelect('@frame') or __mschfSelect('*')\n  window.__mschfSelect = (q='*', seconds=2) => {\n    const root = State.domLayer || document;\n    let sel = [];\n    if (q==='*') sel = [...root.querySelectorAll('[data-mschf=\"1\"]')];\n    else if (q.startsWith('@')) sel = [...root.querySelectorAll(`[data-mschf-family=\"${q.slice(1)}\"]`)];\n    else sel = [...root.querySelectorAll(`[data-mschf-kind=\"${q}\"]`)];\n    sel.forEach(n=>n.classList.add('mschf-highlight'));\n    setTimeout(()=> sel.forEach(n=>n.classList.remove('mschf-highlight')), seconds*1000);\n    return sel.length;\n  };\n  // Find overlay nodes containing text (e.g., 'READ ONLY') and highlight\n  window.__mschfFind = (text, seconds=3) => {\n    const t = String(text||'').toLowerCase(); if (!t) return 0;\n    const nodes = [...(State.domLayer||document).querySelectorAll('[data-mschf=\"1\"]')].filter(n => (n.textContent||'').toLowerCase().includes(t));\n    nodes.forEach(n=>n.classList.add('mschf-highlight'));\n    setTimeout(()=> nodes.forEach(n=>n.classList.remove('mschf-highlight')), seconds*1000);\n    console.log('[MSCHF] __mschfFind', t, nodes);\n    return nodes.length;\n  };\n  // Click-to-inspect overlay: __mschfPick(1) then click a visual\n  window.__mschfPick = (on=1, timeoutMs=5000) => {\n    const enable = !!(+on);\n    const layer = State.domLayer; if (!layer) return false;\n    State._picking = enable;\n    layer.style.cursor = enable ? 'crosshair' : '';\n    const handler = (ev) => {\n      const target = ev.target.closest('[data-mschf=\"1\"]');\n      if (!target) return;\n      ev.preventDefault(); ev.stopPropagation();\n      const id = +target.dataset.mschfId;\n      const a = [...State.actors].find(x=>x._id===id);\n      const fam = Object.entries(State.families).find(([,set])=>set.has(a))?.[0]||'?';\n      const r = target.getBoundingClientRect();\n      console.log('[MSCHF] pick', { id:a?._id, kind:a?.kind, family:fam, text:(target.textContent||'').trim(), bbox:{x:Math.round(r.x),y:Math.round(r.y),w:Math.round(r.width),h:Math.round(r.height)}, node:target, actor:a });\n      target.classList.add('mschf-highlight'); setTimeout(()=>target.classList.remove('mschf-highlight'), 2000);\n      // auto-exit after one pick\n      if (State._picking) { State._picking=false; layer.style.cursor=''; }\n    };\n    if (enable) {\n      layer.addEventListener('click', handler, { capture:true, passive:false });\n      State._pickHandler = handler;\n      if (timeoutMs>0) setTimeout(()=>{ if (State._picking) { State._picking=false; layer.style.cursor=''; } }, timeoutMs);\n    } else if (State._pickHandler) {\n      layer.removeEventListener('click', State._pickHandler, { capture:true });\n      State._pickHandler=null;\n    }\n    return enable;\n  };\n  window.__mschfRecompose = (mode='auto') => { State.config.recompose = String(mode).toLowerCase(); };\n  window.__mschfRare = (on=1) => { State.config.rare = !!(+on); };\n  window.__mschfStats = () => ({ counters: { ...C }, sizes: {\n    scaffold: State.families.scaffold.size, ephemera: State.families.ephemera.size, lab: State.families.lab.size, frame: State.families.frame.size\n  }, nodeBudget: State.nodeBudget, nodeCount: State.nodeCount, caps: { ...State.caps }, density: State.density, readingPressure: State.readingPressure, mood: State.mood, visible: State.visible });\n})();\n"
  },
  {
    "path": "src/assets/js/theme-utils.js",
    "content": "// src/assets/js/theme-utils.js\n// Framework-agnostic theme helpers for DaisyUI v5 themes.\n// Exposes a tiny global `ThemeUtils` for non-module usage and works without bundlers.\n(function (global) {\n  \"use strict\";\n\n  var STORAGE_KEY = \"theme\";\n  var THEMES = { light: \"light\", dark: \"dark\" };\n  var DEFAULT = THEMES.light;\n  var DARK_NAME = THEMES.dark;\n  var ALLOWED = [THEMES.light, THEMES.dark];\n\n  function configure(opts) {\n    try {\n      if (!opts || typeof opts !== \"object\") return;\n      if (Array.isArray(opts.allowed) && opts.allowed.length) {\n        ALLOWED = opts.allowed.map(String);\n      }\n      if (opts.defaultTheme && typeof opts.defaultTheme === \"string\") {\n        DEFAULT = opts.defaultTheme;\n      }\n      if (opts.darkTheme && typeof opts.darkTheme === \"string\") {\n        DARK_NAME = opts.darkTheme;\n      }\n      if (opts.storageKey && typeof opts.storageKey === \"string\") {\n        STORAGE_KEY = opts.storageKey;\n      }\n    } catch (_) { /* noop */ }\n  }\n\n  function getTheme() {\n    var el = document.documentElement;\n    var t = el.getAttribute(\"data-theme\");\n    if (!t || ALLOWED.indexOf(t) === -1) {\n      // Fallback to storage then default\n      try {\n        var s = localStorage.getItem(STORAGE_KEY);\n        if (s && ALLOWED.indexOf(s) !== -1) t = s;\n      } catch (_) {}\n    }\n    return ALLOWED.indexOf(t) !== -1 ? t : DEFAULT;\n  }\n\n  function setTheme(name, persist, source) {\n    if (ALLOWED.indexOf(name) === -1) return;\n    var el = document.documentElement;\n    el.setAttribute(\"data-theme\", name);\n    el.dataset.themeSource = source || \"user\";\n    var meta = document.querySelector('meta[name=\"color-scheme\"]');\n    if (meta) meta.setAttribute(\"content\", name === DEFAULT ? \"light dark\" : \"dark light\");\n    if (persist) {\n      try { localStorage.setItem(STORAGE_KEY, name); } catch (_) {}\n    }\n    try { document.dispatchEvent(new CustomEvent(\"themechange\", { detail: { theme: name, source: source || \"user\" } })); } catch (_) {}\n  }\n\n  function toggleTheme(persist) {\n    var cur = getTheme();\n    // Prefer binary toggle between DEFAULT and DARK_NAME\n    var next = cur === DARK_NAME ? DEFAULT : DARK_NAME;\n    setTheme(next, persist !== false, \"toggle\");\n    return next;\n  }\n\n  function initEarly() {\n    // Run as early as possible in <head> to avoid FART.\n    try {\n      var stored = localStorage.getItem(STORAGE_KEY);\n      var picked = (stored && ALLOWED.indexOf(stored) !== -1)\n        ? stored\n        : (window.matchMedia && window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? DARK_NAME : DEFAULT);\n      document.documentElement.setAttribute(\"data-theme\", picked);\n      document.documentElement.dataset.themeSource = stored ? \"storage\" : \"default\";\n      var meta = document.querySelector('meta[name=\"color-scheme\"]') || (function (){ var m=document.createElement(\"meta\"); m.name = \"color-scheme\"; document.head.appendChild(m); return m; })();\n      meta.content = (picked === DEFAULT) ? \"light dark\" : \"dark light\";\n    } catch (_) {\n      document.documentElement.setAttribute(\"data-theme\", DEFAULT);\n      document.documentElement.dataset.themeSource = \"fallback\";\n    }\n  }\n\n  function onChange(handler) {\n    if (typeof handler !== \"function\") return function () {};\n    var fn = function (e) { handler(e?.detail?.theme || getTheme(), e?.detail?.source || \"event\"); };\n    document.addEventListener(\"themechange\", fn);\n    return function unsubscribe() { document.removeEventListener(\"themechange\", fn); };\n  }\n\n  var api = { configure: configure, getTheme: getTheme, setTheme: setTheme, toggleTheme: toggleTheme, initEarly: initEarly, onChange: onChange, THEMES: THEMES };\n  global.ThemeUtils = api;\n})(window);\n"
  },
  {
    "path": "package.json",
    "content": "{\n  \"name\": \"effusion_labs_final\",\n  \"version\": \"1.0.0\",\n  \"description\": \"This is a digital studio and knowledge base for Effusion Labs, built with Eleventy and the powerful `@photogabble/eleventy-plugin-interlinker`.\",\n  \"keywords\": [],\n  \"license\": \"ISC\",\n  \"author\": \"\",\n  \"type\": \"module\",\n  \"main\": \"index.js\",\n    \"scripts\": {\n    \"start\": \"npm run dev\",\n    \"build\": \"node utils/dev/eleventy-with-codeframes.mjs\",\n    \"preview\": \"ELEVENTY_SERVE=true node utils/dev/eleventy-with-codeframes.mjs --serve\",\n    \"dev\": \"ELEVENTY_SERVE=true node utils/dev/eleventy-with-codeframes.mjs --serve\",\n    \"dev:11ty\": \"ELEVENTY_SERVE=true node utils/dev/eleventy-with-codeframes.mjs --serve\",\n    \"eleventy\": \"npx @11ty/eleventy\",\n    \"eleventy:raw\": \"npx @11ty/eleventy\",\n    \"format\": \"prettier -w .\",\n    \"format:check\": \"prettier -c .\",\n    \"test\": \"c8 node test/integration/runner.spec.mjs\",\n    \"test:watch\": \"node --watch test/integration/runner.spec.mjs\",\n    \"check\": \"npm run format:check && npm run lint && npm run test\",\n    \"lint\": \"npm run lint:advisory && npm run lint:product-links && npm run lint:links\",\n    \"lint:links\": \"markdown-link-check -c oneoff/link-check.config.json README.md\",\n    \"dead-links\": \"npm run lint:links\",\n    \"deps:playwright\": \"playwright install chromium || true\",\n    \"docs:fetch\": \"node utils/build/doc-fetcher.mjs\",\n    \"data:all\": \"npm run data:merge-sections && npm run data:synthesize && npm run data:merge-golden\",\n    \"data:merge-sections\": \"node utils/build/merge-sections.mjs --verbose\",\n    \"data:synthesize\": \"node utils/build/synthesize.mjs --verbose\",\n    \"data:merge-golden\": \"node utils/build/merge-golden.mjs --verbose\",\n    \"lint:advisory\": \"node utils/scripts/validation/lint-archive-namespace.mjs\",\n    \"lint:product-links\": \"node utils/scripts/validation/lint-product-links.mjs\",\n    \"mcp:dev\": \"node mcp-stack/gateway/server.mjs\",\n    \"mcp:integration\": \"node mcp-stack/tests/integration.mjs\",\n    \"mcp:test\": \"node mcp-stack/tests/smoke.mjs\",\n    \"patch:ternary\": \"node utils/scripts/patch-njk-ternaries.mjs\",\n    \"report:products\": \"node utils/build/archive-products-report.mjs\",\n    \"scan:ternary\": \"node utils/scripts/scan-njk-ternaries.mjs\",\n    \"style:canon\": \"node utils/scripts/style-canon.mjs\",\n    \"validate:docs\": \"node utils/scripts/validation/validate-docs.js\",\n    \"verify:patches\": \"node utils/scripts/validation/verify-patch-applied.mjs\",\n    \"postinstall\": \"if [ \\\"${PATCH_PACKAGE_RUN:-1}\\\" != \\\"0\\\" ] && [ -x node_modules/.bin/patch-package ]; then patch-package; fi\"\n  },\n  \"devDependencies\": {\n    \"@11ty/eleventy\": \"3.1.2\",\n    \"@11ty/eleventy-img\": \"6.0.4\",\n    \"@11ty/eleventy-navigation\": \"1.0.4\",\n    \"@11ty/eleventy-plugin-rss\": \"2.0.4\",\n    \"@11ty/eleventy-plugin-vite\": \"7.0.0\",\n    \"@babel/parser\": \"7.28.4\",\n    \"@mozilla/readability\": \"0.6.0\",\n    \"@photogabble/eleventy-plugin-interlinker\": \"1.1.0\",\n    \"@playwright/test\": \"1.55.0\",\n    \"@quasibit/eleventy-plugin-schema\": \"1.11.1\",\n    \"@quasibit/eleventy-plugin-sitemap\": \"2.2.0\",\n    \"@shikijs/markdown-it\": \"3.12.2\",\n    \"@shikijs/transformers\": \"3.12.2\",\n    \"@tailwindcss/typography\": \"0.5.16\",\n    \"@tailwindcss/vite\": \"4.1.13\",\n    \"acorn\": \"8.15.0\",\n    \"ajv\": \"8.17.1\",\n    \"ajv-formats\": \"3.0.1\",\n    \"axios\": \"1.12.1\",\n    \"c8\": \"10.1.3\",\n    \"chalk\": \"5.6.2\",\n    \"colorette\": \"2.0.16\",\n    \"concurrently\": \"9.2.1\",\n    \"daisyui\": \"5.1.10\",\n    \"date-fns\": \"4.1.0\",\n    \"fast-glob\": \"3.3.3\",\n    \"fd-find\": \"1.2.0\",\n    \"fs-extra\": \"11.3.1\",\n    \"gray-matter\": \"4.0.3\",\n    \"hast-util-select\": \"6.0.4\",\n    \"jscodeshift\": \"^17.3.0\",\n    \"jsdom\": \"^26.1.0\",\n    \"libnpmsearch\": \"9.0.0\",\n    \"lucide\": \"0.544.0\",\n    \"luxon\": \"3.7.2\",\n    \"magic-string\": \"0.30.19\",\n    \"markdown-it\": \"14.1.0\",\n    \"markdown-it-anchor\": \"9.2.0\",\n    \"markdown-it-attrs\": \"4.3.1\",\n    \"markdown-it-footnote\": \"4.0.0\",\n    \"markdown-link-check\": \"3.13.7\",\n    \"meriyah\": \"6.1.4\",\n    \"micromatch\": \"4.0.8\",\n    \"natural\": \"8.1.0\",\n    \"node-cache\": \"5.1.2\",\n    \"nodemon\": \"3.1.10\",\n    \"npm-registry-fetch\": \"19.0.0\",\n    \"nunjucks\": \"3.2.4\",\n    \"ora\": \"8.2.0\",\n    \"p-limit\": \"7.1.1\",\n    \"p-queue\": \"8.1.1\",\n    \"p-retry\": \"7.0.0\",\n    \"patch-package\": \"8.0.0\",\n    \"picocolors\": \"1.1.1\",\n    \"playwright-extra\": \"4.3.6\",\n    \"prettier\": \"3.6.2\",\n    \"proxy-chain\": \"2.5.9\",\n    \"recast\": \"0.23.11\",\n    \"rehype-parse\": \"9.0.1\",\n    \"rehype-remark\": \"10.0.1\",\n    \"rehype-sanitize\": \"6.0.0\",\n    \"remark-footnotes\": \"4.0.1\",\n    \"remark-gfm\": \"4.0.1\",\n    \"remark-math\": \"6.0.0\",\n    \"remark-smartypants\": \"3.0.2\",\n    \"remark-stringify\": \"11.0.0\",\n    \"shiki\": \"3.12.2\",\n    \"slugify\": \"1.6.6\",\n    \"tailwindcss\": \"4.1.13\",\n    \"tree-cli\": \"0.6.7\",\n    \"undici\": \"7.16.0\",\n    \"unified\": \"11.0.5\",\n    \"vite\": \"7.1.5\",\n    \"yaml\": \"2.8.1\",\n    \"yargs\": \"18.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=24.0.0\"\n  }\n}\n"
  },
  {
    "path": "vite.config.mjs",
    "content": "// vite.config.mjs\nimport tailwind from '@tailwindcss/vite';\n\nexport default {\n    plugins: [tailwind()],\n    css: { devSourcemap: true }\n};\n"
  },
  {
    "path": "tailwind.config.mjs",
    "content": "// tailwind.config.mjs\n// Minimal config; everything else is done in CSS (v4 “CSS-first”).\nexport default {\n  theme: {\n    extend: {\n      screens: {\n        \"3xl\": \"1920px\",\n        \"4xl\": \"2560px\",\n      },\n      fontFamily: {\n        heading: [\"Space Grotesk\", \"ui-sans-serif\", \"system-ui\", \"sans-serif\"],\n        body: [\"Rubik\", \"ui-sans-serif\", \"system-ui\", \"sans-serif\"],\n        mono: [\"IBM Plex Mono\", \"ui-monospace\", \"SFMono-Regular\", \"Menlo\", \"monospace\"],\n      },\n      letterSpacing: {\n        brutal: \"-0.025em\",\n        tightish: \"-0.01em\",\n        mega: \"0.08em\",\n      },\n      colors: {\n        background: \"rgb(var(--color-bg) / <alpha-value>)\",\n        surface: \"rgb(var(--color-surface) / <alpha-value>)\",\n        text: \"rgb(var(--color-text) / <alpha-value>)\",\n        border: \"rgb(var(--color-border) / <alpha-value>)\",\n        codebg: \"rgb(var(--color-code-bg) / <alpha-value>)\",\n        codetext: \"rgb(var(--color-code-text) / <alpha-value>)\",\n        electric: \"rgb(0 191 255 / <alpha-value>)\",\n      },\n      typography: ({ theme }) => ({\n        DEFAULT: {\n          css: {\n            color: \"hsl(var(--bc))\",\n            h1: {\n              fontFamily: theme(\"fontFamily.heading\"),\n              fontWeight: \"800\",\n              letterSpacing: theme(\"letterSpacing.brutal\"),\n              textTransform: \"uppercase\",\n              color: \"hsl(var(--bc))\",\n            },\n            h2: {\n              fontFamily: theme(\"fontFamily.heading\"),\n              fontWeight: \"800\",\n              letterSpacing: theme(\"letterSpacing.brutal\"),\n              textTransform: \"uppercase\",\n              color: \"hsl(var(--bc))\",\n            },\n            h3: {\n              fontFamily: theme(\"fontFamily.heading\"),\n              fontWeight: \"700\",\n              letterSpacing: theme(\"letterSpacing.tightish\"),\n              color: \"hsl(var(--bc))\",\n            },\n            p: {\n              fontFamily: theme(\"fontFamily.body\"),\n              letterSpacing: theme(\"letterSpacing.tightish\"),\n            },\n            a: {\n              color: \"hsl(var(--p))\",\n              textDecoration: \"none\",\n              fontWeight: \"600\",\n              \"&:hover\": { color: \"hsl(var(--pf))\", textDecoration: \"underline\" },\n            },\n            strong: { color: \"hsl(var(--bc))\" },\n            blockquote: {\n              borderLeftColor: \"hsl(var(--bc)/.22)\",\n              color: \"hsl(var(--bc)/.85)\",\n            },\n            code: {\n              fontFamily: theme(\"fontFamily.mono\"),\n              backgroundColor: \"hsl(var(--b2))\",\n              color: \"hsl(var(--bc))\",\n              padding: \"0.15em 0.35em\",\n              borderRadius: \"0.25rem\",\n            },\n            \"code::before\": { content: \"none\" },\n            \"code::after\": { content: \"none\" },\n            hr: { borderColor: \"hsl(var(--bc)/.22)\" },\n            \"ul > li::marker\": { color: \"hsl(var(--p))\" },\n            \"ol > li::marker\": { color: \"hsl(var(--p))\" },\n            table: { borderColor: \"hsl(var(--bc)/.14)\" },\n            thead: { borderBottomColor: \"hsl(var(--bc)/.22)\" },\n          },\n        },\n        invert: {\n          css: {\n            color: \"hsl(var(--bc))\",\n            a: { color: \"hsl(var(--p))\", \"&:hover\": { color: \"hsl(var(--pf))\" } },\n            blockquote: { borderLeftColor: \"hsl(var(--bc)/.32)\" },\n            hr: { borderColor: \"hsl(var(--bc)/.32)\" },\n          },\n        },\n      }),\n    },\n  },\n  plugins: [], // Tailwind v4 plugins are activated in CSS via @plugin\n};\n"
  }
]
