// ==UserScript==
// @name         IG Mirror — jQuery Edition (ghost baseline fix)
// @namespace    https://ig-mirror.local/
// @version      0.13.0
// @description  Side mirror for Instagram tag/search grids using jQuery. Per-tag/search state, route-aware clear & reload, stable ghost (baseline-only), date debugging, and hydration via GraphQL.
// @match        https://www.instagram.com/explore/tags/*
// @match        https://www.instagram.com/explore/search/keyword/*
// @grant        GM_addStyle
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_xmlhttpRequest
// @require      https://code.jquery.com/jquery-3.7.1.min.js#sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=
// @run-at       document-idle
// @connect      www.instagram.com
// @connect      i.instagram.com
// ==/UserScript==

(function($){
  'use strict';

  // ─────────────────────────── Route helpers (per tag/search) ───────────────────────────
  function routeCtx(){
    const u = new URL(location.href);
    if(u.pathname.startsWith('/explore/tags/')){
      const parts = u.pathname.split('/').filter(Boolean);
      const tag = (parts[2]||'').toLowerCase();
      return { scope:'tag', key:`tag:${tag}`, label:`#${tag}` };
    }
    if(u.pathname.startsWith('/explore/search/keyword/')){
      const q = (u.searchParams.get('q')||'').trim().toLowerCase();
      return { scope:'search', key:`search:${q}`, label:q?`search: ${q}`:'search' };
    }
    return { scope:'path', key:`path:${u.pathname}${u.search}`, label:u.pathname };
  }

  let ROUTE = routeCtx();
  let STORAGE_KEY = 'igmjq_state::' + ROUTE.key;

  // ─────────────────────────── State ───────────────────────────
  let SORT_DIR = GM_getValue('igmjq_sort', 'asc'); // 'asc' | 'desc'
  let PAUSED = false;
  let SHOW_MISSING = true; // hide/show ghosts
  let DEBUG_OPEN = false;

  // Ghost baseline: compute exactly once per route. We do NOT live-update ghost after baseline.
  let GHOST_BASELINE_DONE = false;

  // shortcode -> record
  // record = { href, img, img_source, ts, ts_source, ts_raw, live (true|false|null), when }
  const items = new Map();
  const queue = [];
  let inflight = 0;
  const CONCURRENCY = 2;
  let APP_ID = null;

  // ─────────────────────────── Styles + UI ───────────────────────────
  GM_addStyle(`
    #igmjq-panel{position:fixed;top:0;right:0;width:380px;height:100vh;z-index:999999;
      background:rgba(24,24,24,.86);backdrop-filter:blur(8px);color:#f5f5f5;border-left:1px solid #363636;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;transform:translateX(0);transition:transform .25s}
    #igmjq-panel[hidden]{transform:translateX(100%)}
    #igmjq-panel .head{display:flex;align-items:center;justify-content:space-between;padding:8px 10px}
    #igmjq-panel .head .title{font-weight:600}
    #igmjq-panel .head .subtitle{color:#9aa0a6;font-size:12px;margin-left:6px}
    #igmjq-panel .head .buttons{display:flex;gap:6px;flex-wrap:wrap}
    #igmjq-panel .head .buttons button{all:unset;cursor:pointer;background:#2a2a2a;border-radius:6px;padding:6px 8px;color:#cfcfcf}
    #igmjq-panel .head .buttons button:hover{color:#fff}
    #igmjq-panel .body{height:calc(100% - 52px);overflow:auto;padding:10px}
    #igmjq-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
    #igmjq-grid a{display:block;position:relative;aspect-ratio:1/1;background:#2a2a2a;border-radius:6px;overflow:hidden}
    #igmjq-grid img{width:100%;height:100%;object-fit:cover;display:block}
    .igmjq-badge{position:absolute;top:6px;right:6px;background:rgba(0,0,0,.55);color:#fff;font-size:10px;padding:2px 5px;border-radius:10px}
    #igmjq-debug{margin-top:10px;background:#1a1a1a;border:1px solid #333;border-radius:8px;padding:8px;max-height:45vh;overflow:auto}
    #igmjq-debug table{width:100%;border-collapse:collapse;font-size:12px;color:#ddd}
    #igmjq-debug th,#igmjq-debug td{border-bottom:1px solid #2a2a2a;padding:6px 4px;text-align:left}
    #igmjq-debug .warn{color:#ffbd4a}
  `);

  const $panel = $(`
    <aside id="igmjq-panel">
      <div class="head">
        <div>
          <span class="title">IG Mirror</span>
          <span class="subtitle" id="igmjq-scope"></span>
          <span id="igmjq-count" style="color:#aaa;font-weight:400;margin-left:6px">0</span>
        </div>
        <div class="buttons">
          <button id="igmjq-sort">Sort: <b>${SORT_DIR}</b></button>
          <button id="igmjq-toggle">${PAUSED?'Play':'Pause'}</button>
          <button id="igmjq-missing">${SHOW_MISSING?'Hide missing':'Show missing'}</button>
          <button id="igmjq-debug-btn">${DEBUG_OPEN?'Close debug':'Debug'}</button>
          <button id="igmjq-clear">Clear</button>
        </div>
      </div>
      <div class="body">
        <div id="igmjq-grid"></div>
        <div id="igmjq-debug" ${DEBUG_OPEN?'':'hidden'}></div>
      </div>
    </aside>
  `).appendTo(document.body);

  function updateScopeLabel(){ $('#igmjq-scope').text(`(${ROUTE.label})`); }
  updateScopeLabel();

  // Alt+I toggles panel visibility
  $(document).on('keydown', (e)=>{
    if(e.altKey && String(e.key).toLowerCase()==='i'){
      e.preventDefault();
      $panel.prop('hidden', !$panel.prop('hidden'));
    }
  });

  $('#igmjq-sort').on('click', ()=>{
    SORT_DIR = (SORT_DIR==='asc'?'desc':'asc');
    GM_setValue('igmjq_sort', SORT_DIR);
    $('#igmjq-sort b').text(SORT_DIR);
    render();
  });
  $('#igmjq-toggle').on('click', ()=>{
    PAUSED = !PAUSED;
    $('#igmjq-toggle').text(PAUSED?'Play':'Pause');
  });
  $('#igmjq-missing').on('click', ()=>{
    SHOW_MISSING = !SHOW_MISSING;
    $('#igmjq-missing').text(SHOW_MISSING?'Hide missing':'Show missing');
    render();
  });
  $('#igmjq-debug-btn').on('click', ()=>{
    DEBUG_OPEN = !DEBUG_OPEN;
    $('#igmjq-debug-btn').text(DEBUG_OPEN?'Close debug':'Debug');
    $('#igmjq-debug').prop('hidden', !DEBUG_OPEN);
    if(DEBUG_OPEN) renderDebug();
  });
  $('#igmjq-clear').on('click', ()=>{
    if(confirm(`Clear mirrored items for ${ROUTE.label}?`)){
      items.clear();
      GM_setValue(STORAGE_KEY, null);
      render();
      renderDebug();
    }
  });

  // ─────────────────────────── Utils ───────────────────────────
  const dedupe = (arr)=>[...new Set(arr)];
  const getShortcode = (href)=>{ try{ const u = new URL(href, location.origin); const m = u.pathname.match(/^\/(?:p|reel)\/([^\/]+)/); return m?m[1]:null; }catch{ return null; } };
  const bestFromResources = (res)=>{ if(!res) return null; if(Array.isArray(res)) return res[res.length-1]?.src || res[res.length-1]?.url || null; if(res.candidates) return res.candidates[0]?.url || null; return null; };
  const persist = ()=>{ const dump = JSON.stringify([...items.entries()]); GM_setValue(STORAGE_KEY, dump); };
  const restore = ()=>{ try{ const dump = GM_getValue(STORAGE_KEY); if(!dump) return; const ent = JSON.parse(dump); for(const [k,v] of ent) items.set(k,v);}catch{} };
  const toIso = (ms)=>Number.isFinite(ms)? new Date(ms).toISOString() : '';

  function findAppId(){ if(APP_ID) return APP_ID; $('script[type="application/json"]').each(function(){ const txt=this.textContent||''; const m=txt.match(/"APP_ID":"(\d+)"/); if(m){ APP_ID=m[1]; return false; } }); return APP_ID; }

  // ─────────────────────────── GraphQL hydrators (taken_at preferred) ───────────────────────────
  function gqlShortcodeHash(shortcode){
    const url = `https://www.instagram.com/graphql/query/?query_hash=2c4c2e343a8f64c625ba02b2aa12c7f8&variables=${encodeURIComponent(JSON.stringify({shortcode}))}`;
    return new Promise((resolve,reject)=>{
      GM_xmlhttpRequest({ method:'GET', url, onload:(r)=>{ try{ const obj=JSON.parse(r.responseText); const node=obj?.data?.shortcode_media; if(node){ const tsRaw=(typeof node.taken_at_timestamp==='number')?node.taken_at_timestamp:null; resolve({ ts:Number.isFinite(tsRaw)?tsRaw*1000:Number.NaN, ts_source: tsRaw!=null?'hash.taken_at_timestamp':'hash.none', ts_raw: tsRaw, img: bestFromResources(node.display_resources) || node.display_url || null, img_source: node.display_resources?'hash.display_resources':(node.display_url?'hash.display_url':'hash.none') }); } else if(obj?.status==='fail'){ reject(new Error(obj.message||'fail')); } else { reject(new Error('no_data')); } }catch(e){ reject(e);} }, onerror: reject });
    });
  }

  function gqlShortcodeQueryId(shortcode){
    const url = `https://www.instagram.com/graphql/query/?query_id=9496392173716084&variables=${encodeURIComponent(JSON.stringify({ shortcode, __relay_internal__pv__PolarisFeedShareMenurelayprovider:true, __relay_internal__pv__PolarisIsLoggedInrelayprovider:true }))}`;
    const headers = {}; const app=findAppId(); if(app) headers['X-IG-App-ID']=app;
    return new Promise((resolve,reject)=>{
      GM_xmlhttpRequest({ method:'GET', url, headers, onload:(r)=>{ try{ const obj=JSON.parse(r.responseText); const node=obj?.data?.xdt_api__v1__media__shortcode__web_info?.items?.[0]; if(node){ const tsPicked = (typeof node.taken_at==='number')?node.taken_at : (typeof node.taken_at_timestamp==='number')?node.taken_at_timestamp : null; const tsSource = (typeof node.taken_at==='number')?'id.taken_at' : (typeof node.taken_at_timestamp==='number')?'id.taken_at_timestamp' : 'id.none'; let imgUrl=null, imgSrc='id.none'; if(node.image_versions2?.candidates){ imgUrl=bestFromResources(node.image_versions2.candidates); imgSrc='id.image_versions2'; } else if(node.display_resources){ imgUrl=bestFromResources(node.display_resources); imgSrc='id.display_resources'; } resolve({ ts:Number.isFinite(tsPicked)?tsPicked*1000:Number.NaN, ts_source: tsSource, ts_raw: tsPicked, img: imgUrl||null, img_source: imgSrc }); } else { reject(new Error('no_items')); } }catch(e){ reject(e);} }, onerror: reject });
    });
  }

  function pump(){ if(PAUSED) return; while(inflight<CONCURRENCY && queue.length){ const sc=queue.shift(); inflight++; hydrate(sc).finally(()=>{ inflight--; render(); if(DEBUG_OPEN) renderDebug(); pump(); }); } }

  async function hydrate(shortcode){
    const rec = items.get(shortcode); if(!rec) return; if(Number.isFinite(rec.ts) && rec.img) return;
    try{ const b = await gqlShortcodeQueryId(shortcode); merge(shortcode,b); if(!items.get(shortcode).img){ try{ merge(shortcode, await gqlShortcodeHash(shortcode)); }catch{} } }
    catch{ try{ merge(shortcode, await gqlShortcodeHash(shortcode)); }catch(e2){} }
  }

  function merge(shortcode,data){
    const rec = items.get(shortcode); if(!rec) return;
    if(data.img && !rec.img){ rec.img=data.img; rec.img_source=data.img_source||rec.img_source||'unknown'; }
    if(Number.isFinite(data.ts) && !Number.isFinite(rec.ts)){
      rec.ts=data.ts; rec.ts_source=data.ts_source||'unknown'; rec.ts_raw=(typeof data.ts_raw!=='undefined')?data.ts_raw:(Number.isFinite(data.ts)?Math.round(data.ts/1000):null);
    }
    if(!Number.isFinite(rec.ts)){
      rec.ts_source=rec.ts_source||'none';
      if(typeof rec.ts_raw==='undefined') rec.ts_raw=null;
      console.warn('[IGM][undated]', shortcode, {source:rec.ts_source, raw:rec.ts_raw});
    }
    persist();
  }

  // ─────────────────────────── Scanning & render (ghost baseline once) ───────────────────────────
  function findDomTimeForShortcode(sc){
    try{
      const $a = $(`a[href*="/${sc}"]`).first(); if(!$a.length) return null;
      const $time = $a.closest('article,div').find('time[datetime]').first();
      if($time.length){ const iso=$time.attr('datetime'); const ms=Date.parse(iso); if(Number.isFinite(ms)) return { ms, iso, source:'dom.time' }; }
    }catch{}
    return null;
  }

  function scanOnce(){
    if(PAUSED) return;
    const anchors = $('a[href^="/p/"], a[href^="/reel/"]').map((_,a)=>a.href).get();
    const seen = new Set();

    for(const href of dedupe(anchors)){
      const sc = getShortcode(href); if(!sc) continue; seen.add(sc);
      let rec = items.get(sc);
      if(!rec){
        rec = { href, img:null, img_source:null, ts:Number.NaN, ts_source:null, ts_raw:null, live:true, when:Date.now() };
        items.set(sc, rec);
        const $img = $(`a[href*="${sc}"]`).find('img').first();
        const srcset = $img.attr('srcset'); const src = $img.attr('src');
        if(srcset){ const best = srcset.split(',').map(s=>s.trim().split(' ')[0]).pop(); if(best){ rec.img=best; rec.img_source='dom.srcset'; } }
        else if(src){ rec.img=src; rec.img_source='dom.src'; }
        const dt = findDomTimeForShortcode(sc); if(dt){ rec.ts=dt.ms; rec.ts_source=dt.source; rec.ts_raw=Math.round(dt.ms/1000); }
        queue.push(sc);
      } else {
        rec.href = href;
        if(!rec.img){
          const $img = $(`a[href*="${sc}"]`).find('img').first();
          const srcset=$img.attr('srcset'); const src=$img.attr('src');
          if(srcset){ const best = srcset.split(',').map(s=>s.trim().split(' ')[0]).pop(); if(best){ rec.img=best; rec.img_source=rec.img_source||'dom.srcset'; } }
          else if(src){ rec.img=src; rec.img_source=rec.img_source||'dom.src'; }
        }
        if(!Number.isFinite(rec.ts)){
          const dt2 = findDomTimeForShortcode(sc); if(dt2){ rec.ts=dt2.ms; rec.ts_source=dt2.source; rec.ts_raw=Math.round(dt2.ms/1000); }
        }
        // IMPORTANT: do NOT touch rec.live here if baseline is done. We never flip ghost live after baseline.
      }
    }

    // Freeze ghost baseline exactly once per route: present-at-load => live:true, others => live:false
    if(!GHOST_BASELINE_DONE){
      for(const [sc, rec] of items){
        if(rec.live == null){ // restored from storage without a fresh creation this session
          rec.live = seen.has(sc);
        }
      }
      GHOST_BASELINE_DONE = true;
      persist();
    }

    persist();
    render();
    if(DEBUG_OPEN) renderDebug();
    pump();
  }

  const debouncedScan = debounce(scanOnce, 300);
  function debounce(fn, ms){ let t; return ()=>{ clearTimeout(t); t=setTimeout(fn, ms); }; }

  const mo = new MutationObserver((muts)=>{
    if(PAUSED) return;
    for(const m of muts){
      if(m.type==='childList' && (m.addedNodes?.length || m.removedNodes?.length)){ debouncedScan(); return; }
      if(m.type==='attributes'){ debouncedScan(); return; }
    }
  });

  function render(){
    let arr = [...items.values()];
    if(!SHOW_MISSING) arr = arr.filter(x=>x.live!==false);

    arr.sort((A,B)=>{
      const a = Number.isFinite(A.ts)?A.ts:Infinity;
      const b = Number.isFinite(B.ts)?B.ts:Infinity;
      let d = a-b; if(SORT_DIR==='desc') d = -d; if(d!==0) return d; return A.when - B.when;
    });

    const $g = $('#igmjq-grid').empty();
    for(const it of arr){
      const $a = $('<a target="_blank" rel="noopener noreferrer nofollow">').attr('href', it.href);
      const $img = $('<img alt="">'); if(it.img) $img.attr('src', it.img); $a.append($img);
      if(it.live===false){ $a.append('<div class="igmjq-badge">ghost</div>'); }
      else if(!Number.isFinite(it.ts)){ $a.append('<div class="igmjq-badge">undated</div>'); }
      $g.append($a);
    }
    $('#igmjq-count').text(String(arr.length));
  }

  function renderDebug(){
    const rows = [...items.entries()].map(([sc,it])=>{
      const undated = !Number.isFinite(it.ts);
      return `<tr>
        <td><code>${sc}</code></td>
        <td>${undated?'<span class="warn">undated</span>':toIso(it.ts)}</td>
        <td>${it.ts_source||''}</td>
        <td>${(it.ts_raw??'')}</td>
        <td>${it.img_source||''}</td>
        <td>${it.live===false?'ghost':(it.live===true?'live':'(pending)')}</td>
      </tr>`;
    }).join('');
    $('#igmjq-debug').html(`
      <table>
        <thead>
          <tr><th>shortcode</th><th>date</th><th>date source</th><th>date raw</th><th>img source</th><th>status</th></tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `);
  }

  // ─────────────────────────── Route change detection (clear + load) ───────────────────────────
  function onRouteChange(){
    const next = routeCtx();
    if(next.key === ROUTE.key) return; // same scope

    ROUTE = next;
    STORAGE_KEY = 'igmjq_state::' + ROUTE.key;
    updateScopeLabel();

    // Clear in-memory and load per-route snapshot
    items.clear();
    restore();

    // Reset live to null (pending) for restored entries; baseline will set them once.
    items.forEach(v=>{ v.live = null; });

    // Reset baseline for new route
    GHOST_BASELINE_DONE = false;

    render();
    renderDebug();
    scanOnce();
  }

  // Patch history to fire a synthetic event when SPA changes URL
  (function patchHistory(){
    const ev = ()=>window.dispatchEvent(new Event('locationchange'));
    const _ps = history.pushState; history.pushState = function(){ const r=_ps.apply(this, arguments); ev(); return r; };
    const _rs = history.replaceState; history.replaceState = function(){ const r=_rs.apply(this, arguments); ev(); return r; };
    window.addEventListener('popstate', ev);
    window.addEventListener('locationchange', onRouteChange);
  })();

  // ─────────────────────────── Boot per-route ───────────────────────────
  restore();
  items.forEach(v=>{ v.live = null; }); // pending until first baseline
  GHOST_BASELINE_DONE = false;
  render();
  renderDebug();
  scanOnce();

  mo.observe(document.body, { childList:true, subtree:true, attributes:true, attributeFilter:['href','src','srcset'] });

})(window.jQuery);
